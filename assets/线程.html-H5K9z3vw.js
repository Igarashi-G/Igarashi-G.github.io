import{_ as n}from"./plugin-vueexport-helper-DlAUqK2U.js";import{c as a,d as p,a as o,b as e,e as s,w as i,r as B,o as d}from"./app-dO6SmK07.js";const g="/assets/%E8%BD%AF%E7%BA%BF%E7%A8%8B-BYEbWpQY.png",l={};function c(m,t){const r=B("Font");return d(),a("div",null,[t[7]||(t[7]=p('<p><strong>线程（<em>thread</em>） ：</strong> 它是 <strong>操作系统运算调度</strong> 的最小单位，它被包含在 <a href="/back_end/python/base/%E8%B5%84%E6%BA%90%E8%B0%83%E5%BA%A6/%E8%BF%9B%E7%A8%8B">进程</a> 之中，是进程中的实际运作单位</p><h2 id="_1-区分概念" tabindex="-1"><a class="header-anchor" href="#_1-区分概念"><span>1. 区分概念</span></a></h2><h3 id="_1-cpu-级别的线程" tabindex="-1"><a class="header-anchor" href="#_1-cpu-级别的线程"><span>1. CPU 级别的线程：</span></a></h3><p><strong>此线程非彼线程</strong>：</p>',4)),o("p",null,[t[3]||(t[3]=e("我们买硬件时常说如：")),t[4]||(t[4]=o("code",null,"CPU 酷睿i9-11900K 8核16线程",-1)),t[5]||(t[5]=e("，这里的线程，")),o("strong",null,[t[1]||(t[1]=e("意味着是能够同时")),s(r,null,{default:i(()=>t[0]||(t[0]=[e("并行执行")])),_:1}),t[2]||(t[2]=e(" 16 个程序"))]),t[6]||(t[6]=e(" 的意思"))]),t[8]||(t[8]=p('<p>我们知道，程序的多道执行，是被操作系统封装代码为了进程，给了上下文，再分配内存，最后靠 PBC 来实现调度执行的，见<a href="/back_end/python/base/%E8%B5%84%E6%BA%90%E8%B0%83%E5%BA%A6/%E8%BF%9B%E7%A8%8B#%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">进程</a></p><blockquote><p>因此，多道程序的执行，就是利用 CPU 多核、多线程，来同时并发、分片轮询执行进程的过程</p></blockquote><h3 id="_2-提高-cpu-的利用率" tabindex="-1"><a class="header-anchor" href="#_2-提高-cpu-的利用率"><span>2. 提高 CPU 的利用率：</span></a></h3><p>有了 CPU 的多线程，多个程序可以分片并行执行了，但是此时利用率却不一定高</p><blockquote><p>现在要同时从 16 个网站下载数据，假设 CPU 多核没有其他程序在运行或抢占资源，如果设计为开 16 个进程，分别每个进程占一个 CPU 线程去执行，程序如此设计，若进程遇见 IO 时，CPU 就一直 <code>wait</code> ，这对于计算资源简直是巨大的浪费</p></blockquote><p><strong>软线程</strong>：</p><p>因此，同时下载几百个数据，是软件层面去实现线程进行并发处理，这个线程就是软线程，也是编程的时候真正使用的线程概念</p><img src="'+g+'"><p>原理是把线程相关的资源数据，存起来，若出现闲置状态，则挂起当前资源，数据，让 CPU 去处理其他事情，</p><p>比如说 软线程 1 遇见阻塞，线程会让其挂起，切换到软线程 2 继续执行下载任务，所以可以最大程度合理的使用资源</p><p>容纳所有软线程的容器呢称为进程</p><p>若一个应用只有一个进程，那么无论开辟多少软线程，都属于同一个 CPU 线程</p><p>多进程编程：<br> 此时会变成只有一个 CPU 线程在工作，其他 CPU 线程都在看，</p><p>为了避免只是使用同一个 CPU，会对应用创建多个进程</p><p>因为只有创建进程的时候，才会选择空闲的 CPU 线程，来给你分配软线程<br> 已多进程应用的方式来实现对计算机资源的合理利用</p><p>多线程编程：<br> 有一个 1G 的服务器，用来处理前端请求，为每一个请求都开辟一个软线程，<br> 开辟软线程需要存储相关资源在内存里面，一个软线程大约需要 1M 内存<br> 因此 1G 服务器理论上最大支持小于 1024 个软线程，若超过内存，服务器宕机，挂掉</p><p>因此此模式达咩，因此诞生了线程池的概念</p><p>假设最多开辟 5 个线程，当有请求来，就从线程池里面拿一个线程出来</p><p>若同时有 6 个请求来，最后一个请求会等着，服务端会返回一个状态忙，等前面的线程处理完之后，在给你开辟线程</p><p>可以合理利用服务器端的资源，但还是要让用户等一下，已这种方式处理 http 短连接还有优势，</p><p>但是处理实时聊天就不行了，因为实时的场景不能等着。或是有 5M 带宽，但你只开辟了 5 个连接，传输的数据少，对于网络资源来说是个巨大浪费</p><p>添内存的成本远远高于添加网络的成本，因此，诞生了异步编程</p><p>异步编程：</p><p>若有 ABC 三个网站，分别向网卡发送数据，此时底层会有一个线程来不断轮询监听是否有消息发送过来，若监听的 A 站发送了数据，<br> 便往 A 站的处理程序去转发，若监听 B 站发送了数据，便往 B 站的处理程序去转发。因此底层只要做一个事件监听转发机制就可以了</p><p>没必要在处理的阶段开辟新线程，这就是一部思想的原型，为了解决合理利用 IO 资源的问题，因此称为异步 IO 编程</p><p>因此发展出了概念，纤程，一个软线程，可以开辟大量多个纤程，因此就不用担心 IO 资源被浪费了</p><blockquote><p>程序执行时在多个函数中是<strong>顺序串行</strong>的，当一个函数<strong>IO 阻塞</strong>了，<strong>CPU 歇菜</strong>等待，此时程序员会开其他<strong>线程</strong>来让<strong>CPU 不能休息</strong>，达到<code>并发</code>效果</p></blockquote><blockquote><p>但启动线程过多，<code>上下文</code> 消耗大量资源，还要处理<code>锁</code> ，因此创造协程可以在一个线程内检测<strong>IO 阻塞</strong>并<strong>切换阻塞代码</strong>，或<strong>并发 IO 部分的代码</strong> 从而不让 CPU 歇着，也不用处理线程级别的锁</p><p>见下文 <a href="">协程</a></p></blockquote>',28))])}const h=n(l,[["render",c]]),u=JSON.parse('{"path":"/python/%E8%AF%AD%E8%A8%80/%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%BC%96%E7%A8%8B/%E7%BA%BF%E7%A8%8B.html","title":"线程","lang":"zh-CN","frontmatter":{"title":"线程","date":"2021-06-18T00:00:00.000Z","category":["Python","线程"],"tag":["Python","线程"],"description":"线程（thread） ： 它是 操作系统运算调度 的最小单位，它被包含在 进程 之中，是进程中的实际运作单位","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"线程\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2021-06-18T00:00:00.000Z\\",\\"dateModified\\":\\"2023-03-30T14:23:22.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"悦·宝宝\\",\\"url\\":\\"https://github.com/Igarashi-G\\"}]}"],["meta",{"property":"og:url","content":"https://igarashi-g.github.io/python/%E8%AF%AD%E8%A8%80/%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%BC%96%E7%A8%8B/%E7%BA%BF%E7%A8%8B.html"}],["meta",{"property":"og:site_name","content":"悦 ▪ 宝宝"}],["meta",{"property":"og:title","content":"线程"}],["meta",{"property":"og:description","content":"线程（thread） ： 它是 操作系统运算调度 的最小单位，它被包含在 进程 之中，是进程中的实际运作单位"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-03-30T14:23:22.000Z"}],["meta",{"property":"article:tag","content":"线程"}],["meta",{"property":"article:tag","content":"Python"}],["meta",{"property":"article:published_time","content":"2021-06-18T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-03-30T14:23:22.000Z"}]]},"git":{"createdTime":1665194286000,"updatedTime":1680186202000,"contributors":[{"name":"Igarashi","username":"Igarashi","email":"2545369032@qq.com","commits":3,"url":"https://github.com/Igarashi"}]},"readingTime":{"minutes":4.35,"words":1304},"filePathRelative":"python/语言/多任务编程/线程.md","excerpt":"<p><strong>线程（<em>thread</em>） ：</strong> 它是 <strong>操作系统运算调度</strong> 的最小单位，它被包含在 <a href=\\"/back_end/python/base/%E8%B5%84%E6%BA%90%E8%B0%83%E5%BA%A6/%E8%BF%9B%E7%A8%8B\\">进程</a> 之中，是进程中的实际运作单位</p>\\n","autoDesc":true}');export{h as comp,u as data};
