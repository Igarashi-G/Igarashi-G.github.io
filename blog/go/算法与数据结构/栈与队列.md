---
title: 栈与队列
date: 2023-01-25
category:
  - 数据结构
  - go
tag:
  - 数据结构
  - go
star: true
---

**Golang** 数据结构，栈与队列相关



<!-- more -->

# 1. 栈 

**栈**（*stack*）：一种 **后进先出**（*LIFO*）的有序集合，是在操作上受限的线性表，新添加的或者待删除的元素都保存在栈顶，在栈里，新元素靠近栈顶，旧元素都接近栈底

> 注意：任何不在栈顶的元素都无法访问，为了得到栈底的元素，必须先拿掉上面的元素

栈内部的线性 **表尾端叫做栈顶** （*top*），**表头称为栈底**（*bottom*），不含元素的栈称为空栈
栈的插入操作，常称为压栈或者入栈，栈的删除操作常称为出栈或者弹栈

栈和线性表一样，具备两种存储方式：

- **顺序栈**：顺序方式存储
- **链式栈**：链式存储

## 1.1 顺序栈 

利用一组 **地址连续的存储单元** 依次存放自栈底到栈顶的数据元素，同时指定 **top** 指针指向栈顶元素位置  

如图所示： 

<img src="./img/顺序栈.svg">

通常做法是 `top = 0` 表示空栈，下标从 `0` 开始。如果设定了栈底指针 `base` ，那么 `top = base` 则记为空栈

初始化时不推荐限定栈的最大容量，应该先分配基本容量，在使用过程中，如果栈的空间不够大，再逐渐扩大，但为简单起见，不做扩大容量的设计

插入新元素时，**top** 指针 **+1**，删除时 **-1**

### 实现

```go

```



## 1.2 链式栈

**使用链表来实现的栈**，由于是链式存储，链栈基本不存在栈满的情况，除非内存不足！链栈为空其实就是 `top` 为空的时候

我们一般认为向链表中添加元素的操作直接往末尾添加即可，但是在栈中其实有更巧妙的操作，如下所示：  
<img src="./img/链式栈.svg">


## 1.2 共享空间栈

栈的顺序存储结构只允许栈顶进出元素，不存在线性表中插入、删除数据时需要移动数据的问题，但是 **必须预设一个数组的存储空间**

虽然 **Golang** 的切片的容量是动态的，但是变更容量带来的内存拷贝消耗也是可观的，如果数组容量过大，又容易出现利用率不足问题   

对于两个相同类型的栈，可以通过一个数组来最大限度的利用已经开辟好的空间来进行操作

**设计思路**：数组有两个端点， 两个栈有两个栈底， 让一个栈的栈底为数组的始端， 即下标为 **0** 处，另一个栈为数组的末端，即下标为 数组容量 **cap - 1** 处，这样， 两个栈如果增加元素， 就是两端点向中间延伸，（*即两个栈在数组的两端，向中间靠拢*），**top1** 和 **top2** 是栈顶指针，只要他们不见面，两个栈就可以一直使用

一些边界情况:

- 栈 **1** 为空，即 `top1 = -1`
- 栈 **2** 为空，即 `top2 = cap`
- 栈 **1** 满，即 `top1 = cap-1`，且 栈 **2** 为空
- 栈 **2** 满，即 `top2 = 0`，且栈 **1** 为空
- 栈满，即 `top+1 == top2`，也即两个栈见面，两个指针之间相差 **1**

> 注意：两栈共享空间的数据结构，通常用于两栈空间需求相反（*此消彼长*），且数据类型一致！！！   

数据结构如图所示： 
<img src="./img/共享空间栈.svg">