---
title: åˆ†å¸ƒå¼æ³¨å†Œä¼˜åŒ–
date: 2024-05-27
category:
  - Go
tag:
  - GO
  - ä¼˜åŒ–
star: true
---

# åˆ†å¸ƒå¼æ³¨å†Œå¼•å‘çš„ABAé—®é¢˜åŠä¼˜åŒ–

> #### é—®é¢˜èƒŒæ™¯
>
> æœ€è¿‘ä¼˜åŒ–è¾¹ç¼˜ç«¯åˆ†å¸ƒå¼å¾€ä¸­å¿ƒç«¯æ³¨å†Œçš„ä¸šåŠ¡ï¼Œä»¥å‰å®ç°å¾ˆç³™ï¼Œæ— æ³•æ”¯æ’‘å¤§é‡è®¾å¤‡çš„å¤šèŠ‚ç‚¹åŒæ—¶æ³¨å†Œåœºæ™¯ï¼Œç”±äºå…¶æ¯å¥—ç³»ç»Ÿæœ‰å¯èƒ½æ˜¯å•æœºç‰ˆï¼Œä¹Ÿæœ‰å¯èƒ½æ˜¯å°é›†ç¾¤ï¼Œè‹¥å°é›†ç¾¤åˆ™æ¶‰åŠç›¸åŒ `systemUUID` ä½†ä¸åŒ `machineID` çš„å¹¶å‘æ³¨å†Œè¯·æ±‚ï¼Œä¸”åŒæ—¶è¯·æ±‚æ—¶è¾ƒä¸ºç¨€ç–ï¼Œå› æ­¤è¯ç”Ÿäº†å¦‚ä¸‹é—®é¢˜ï¼š
>
> 1. é‡å¤åˆ›å»ºç³»ç»Ÿè®°å½•
> 2. ç«æ€æ¡ä»¶
> 3. æ€§èƒ½ç“¶é¢ˆ
> 4. è¯·æ±‚è¶…æ—¶

![image-20250627154913280](./img/image-20250627154913280.png)  

## 1. åˆæ­¥æƒ³åˆ°çš„è§£å†³æ–¹æ¡ˆ

### 1.1 SingleFlightæ¨¡å¼ (å•é£)

**æ ¸å¿ƒåŸç†**:

- ç›¸åŒkeyçš„å¹¶å‘è¯·æ±‚å…±äº«åŒä¸€ä¸ªæ‰§è¡Œç»“æœ
- ç¬¬ä¸€ä¸ªè¯·æ±‚æ‰§è¡Œï¼Œåç»­è¯·æ±‚ç­‰å¾…ç»“æœ

**âœ… ä¼˜ç‚¹ï¼š** ç®€å•æ— ä¾èµ–ã€åˆå¹¶æ‰§è¡Œï¼ˆå¸¸ç”¨äºè¯»å¤šæˆ–å†™å¹‚ç­‰ï¼‰ã€ç»“æœå…±äº«

**âŒ ç¼ºç‚¹ï¼š** å•æœºã€æ— è¶…æ—¶

**é€‚ç”¨åœºæ™¯**: å•æœºéƒ¨ç½²ã€è¯»å¤šå†™å°‘çš„åœºæ™¯ã€**ç›¸åŒkeyçš„è¯·æ±‚éœ€è¦å…±äº«** ç»“æœ

### 1.2 æ•°æ®åº“å”¯ä¸€çº¦æŸ + é‡è¯•æœºåˆ¶

**æ ¸å¿ƒåŸç†**:

- æ•°æ®åº“å±‚é¢ä¿è¯å”¯ä¸€æ€§
- æ•è·å†²çªé”™è¯¯å¹¶é‡è¯•

**âœ… ä¼˜ç‚¹ï¼š** æ•°æ®åº“çº§åˆ«ä¿è¯ä¸€è‡´æ€§ã€åˆ†å¸ƒå¼æ”¯æŒã€äº‹åŠ¡

**âŒ ç¼ºç‚¹ï¼š** ä¾èµ–DBã€é‡è¯•ã€é”™è¯¯å¤„ç†æœºåˆ¶å¤æ‚ã€DBå‹åŠ›æ˜æ˜¾

**é€‚ç”¨åœºæ™¯**: å¤šå®ä¾‹éƒ¨ç½²ã€å¯¹æ•°æ®åº“æ€§èƒ½è¦æ±‚ä¸é«˜ã€éœ€è¦å¼ºä¸€è‡´æ€§ä¿è¯

### 1.3 Redisåˆ†å¸ƒå¼é”

**æ ¸å¿ƒåŸç†**:

- ä½¿ç”¨Redisçš„SETNXå®ç°åˆ†å¸ƒå¼é”
- ç¡®ä¿åˆ†å¸ƒå¼ç¯å¢ƒä¸‹çš„äº’æ–¥è®¿é—®

**âœ… ä¼˜ç‚¹ï¼š** åˆ†å¸ƒå¼æ”¯æŒã€è¶…æ—¶æ§åˆ¶ã€æ€§èƒ½å¥½

**âŒ ç¼ºç‚¹ï¼š** ä¾èµ– Redis ã€å¢åŠ ç³»ç»Ÿå¤æ‚ã€ç½‘ç»œå»¶è¿Ÿ

**é€‚ç”¨åœºæ™¯ï¼š** å¤šå®ä¾‹éƒ¨ç½²ã€å·²æœ‰ **Redis** åŸºç¡€è®¾æ–½ã€éœ€è¦ä¸¥æ ¼çš„äº’æ–¥æ§åˆ¶

### 1.4 åˆ†æ®µé”

**æ ¸å¿ƒåŸç†**:
- å°†é”ç©ºé—´åˆ†ç‰‡ï¼Œå‡å°‘é”ç«äº‰
- ä½¿ç”¨å“ˆå¸Œç®—æ³•å°†keyæ˜ å°„åˆ°ä¸åŒåˆ†ç‰‡
- æ”¯æŒè¯»å†™é”å’Œè¶…æ—¶æ§åˆ¶

**âœ… ä¼˜ç‚¹ï¼š** ç®€å•æ— ä¾èµ–ã€é«˜æ€§èƒ½ï¼ˆç»†ç²’åº¦å¼±ç«äº‰ï¼‰ã€è¶…æ—¶æ§åˆ¶

**âŒ ç¼ºç‚¹ï¼š** éœ€è¦åˆç†è®¾ç½®åˆ†ç‰‡æ•°é‡ï¼ˆå–å†³äºè§„æ¨¡ï¼‰

**é€‚ç”¨åœºæ™¯ï¼š** é«˜å¹¶å‘åœºæ™¯ã€å•æœºæˆ–é›†ç¾¤éƒ¨ç½²ã€éœ€è¦ç»†ç²’åº¦æ§åˆ¶

å› æ­¤åœºæ™¯æ˜¯åˆ†å¸ƒå¼å¾€ **å•ä¸ªä¸­å¿ƒç«¯æœåŠ¡** å»æ³¨å†Œï¼ŒåŒæ—¶æœŸæœ›å°½é‡ **ç®€å•æ— ä¾èµ–**ï¼ŒåŸºæœ¬ä¸Šå°±åœ¨ **SingleFlight** å’Œ **åˆ†æ®µé”** ä¹‹ä¸­è€ƒè™‘äº†

## 2. åŠ¨æ€åˆ†æ®µé”çš„ABAé—®é¢˜

### 2.1 ABAçš„å‡ºç°

å¬è¯´ **ABAé—®é¢˜** æ˜¯çœ‹ **Mutex** æºç ä¸­ä½¿ç”¨äº†å¤§é‡çš„ **CAS** æ“ä½œæ‰äº†è§£çš„ï¼Œå½“æ—¶ä»¥ä¸ºç¦»æ™®é€šä¸šåŠ¡å¼€å‘ä¼šå¾ˆè¿œï¼Œç›´åˆ°æŒ‰ç…§è‡ªå·±çš„æ€è·¯å®ç°åˆ†æ®µé”æ—¶...

ç”±äºå…¨å±€é”å¤ªé‡ï¼Œé‚é€šè¿‡æ¯ä¸ª `systemUUID` ä¸º **key** æ¥å­˜å‚¨æ¯æŠŠ `sync.Mutex` é”ä¸º **value** çš„æ€è·¯æ¥å®ç°ï¼Œç„¶åé€šè¿‡ `sync.Map` çš„ `LoadOrStore` æ¥è§„é¿å¹¶å‘é—®é¢˜ï¼ŒåŒæ—¶ç©ºé—´åº”è¦é‡Šæ”¾ï¼Œå› æ­¤ä½¿ç”¨åŸå­çš„ `refCount` è§£é”æ—¶å›æ”¶â™»ï¸ï¼ˆåŠ¨æ€ï¼‰ï¼Œç„¶ååˆç‰ˆå°±è¸©å‘ **ABA** äº†

```go
package utils

import (
	"fmt"
	"math/rand"
	"sync"
	"sync/atomic"
	"time"
)

type systemLock struct {
	systemLocks sync.Map
}

type lockWrapper struct {
	mu       *sync.Mutex
	refCount int32 // atomic
}

var (
	instance *systemLock
	once     sync.Once
)

func newGlobalSystemLock() *systemLock {
	once.Do(func() {
		instance = &systemLock{}
	})
	return instance
}

func (s *systemLock) GetSystemLock(systemUUID string) *sync.Mutex {
	// å¿«é€Ÿè·¯å¾„æ£€æŸ¥
	if existing, ok := s.systemLocks.Load(systemUUID); ok {
		wrapper := existing.(*lockWrapper)
		atomic.AddInt32(&wrapper.refCount, 1)
		return wrapper.mu
	}

	// æ…¢é€Ÿè·¯å¾„åˆ›å»ºæ–°é”
	newWrapper := &lockWrapper{
		mu:       &sync.Mutex{},
		refCount: 1,
	}

	// ä½¿ç”¨ LoadOrStore ç¡®ä¿åŸå­æ€§
	if actual, loaded := s.systemLocks.LoadOrStore(systemUUID, newWrapper); loaded {
		wrapper := actual.(*lockWrapper)
		atomic.AddInt32(&wrapper.refCount, 1)
		return wrapper.mu
	}

	return newWrapper.mu
}

func (s *systemLock) ReleaseLock(systemUUID string) {
	actual, ok := s.systemLocks.Load(systemUUID)
	if !ok {
		return
	}

	wrapper := actual.(*lockWrapper)
	if atomic.AddInt32(&wrapper.refCount, -1) == 0 {
		// ä½¿ç”¨ CompareAndDelete ç¡®ä¿å®‰å…¨åˆ é™¤
		for {
			if s.systemLocks.CompareAndDelete(systemUUID, wrapper) {
				return
			}
			// çŸ­æš‚ä¼‘çœ é¿å…å¿™ç­‰å¾…
			time.Sleep(time.Duration(rand.Intn(20)) * time.Microsecond)

			// å†æ¬¡æ£€æŸ¥æ˜¯å¦çœŸçš„éœ€è¦åˆ é™¤
			if existing, ok := s.systemLocks.Load(systemUUID); !ok || existing.(*lockWrapper).refCount > 0 {
				return
			}
		}
	}
}

```

ä¸Šè¿°å®ç°ç†è®ºä¸Šæƒ³åŠ¨æ€åˆ›å»º â€œç»†ç²’åº¦é”â€ï¼Œä½†æ‰‹åŠ¨ç®¡ç†é”çš„ç”Ÿå‘½å‘¨æœŸä»¥åŠ **é¢‘ç¹ä½¿ç”¨åŸå­æ“ä½œå’ŒCAS** æ¥å¼•ç”¨è®¡æ•°ï¼Œæœ‰ä¸å°‘ **bug** å’Œå¤æ‚åº¦ï¼Œæœ€ç›´æ¥çš„å°±æ˜¯ï¼š**ReleaseLock** çš„åˆ é™¤é€»è¾‘æœ‰ **ABA** é—®é¢˜ï¼Œé”è¢«åˆ é™¤ååˆè¢«æ–°å»ºï¼Œ`CompareAndDelete` å¯èƒ½è¯¯åˆ æ–°é”ã€‚

### 2.2 ä»€ä¹ˆæ˜¯ABAé—®é¢˜ï¼Ÿ

**ABAé—®é¢˜æŒ‡çš„æ˜¯ï¼š** æŸä¸ªå¯¹è±¡Aè¢«åˆ é™¤ååˆè¢«æ–°å»ºæˆAï¼ˆåœ°å€/å†…å®¹ä¸€æ ·ï¼‰ï¼Œå¦ä¸€ä¸ªçº¿ç¨‹ä»¥ä¸ºå®ƒè¿˜æ˜¯åŸæ¥çš„Aï¼Œç»“æœåšäº†é”™è¯¯çš„æ“ä½œã€‚

åœ¨è¯¥åœºæ™¯ä¸‹ï¼Œé”å¯¹è±¡è¢«å›æ”¶ååˆè¢«æ–°å»ºï¼Œ`CompareAndDelete` å­˜åœ¨è¯¯åˆ æ–°é”

#### 2.2.1 å‡ºç°æ­¥éª¤

å‡è®¾æœ‰ä¸¤ä¸ªå¹¶å‘ **goroutine**ï¼Œåˆ†åˆ«ä¸º**G1**å’Œ**G2**ï¼Œæ“ä½œåŒä¸€ä¸ª `systemUUID`ï¼š

1. åˆå§‹çŠ¶æ€  `systemLocks` ä¸­æœ‰ `systemUUID`ï¼ŒæŒ‡å‘ `wrapper1`ï¼Œ`refCount=1`
2. **G1å…ˆè§£é”** è°ƒç”¨ `ReleaseLock(systemUUID)`

   - æ‰§è¡Œ`atomic.AddInt32(&wrapper1.refCount, -1)`ï¼Œå˜æˆ0

   - è¿›å…¥forå¾ªç¯ï¼Œå‡†å¤‡ `CompareAndDelete(systemUUID, wrapper1)` 
3. **G2æ­¤æ—¶ä¸Šé”** è°ƒç”¨ `GetSystemLock(systemUUID)` 

   - æ‰§è¡Œ `s.systemLocks.Load(systemUUID)`ï¼Œå‘ç°æœ‰ `wrapper1` (æœ‰é”)ï¼Œä½† `refCount=0`ï¼Œä½†G2è¿˜æ²¡åŠ é”ã€‚

   - **G2** ç»§ç»­æ‰§è¡Œ `s.systemLocks.LoadOrStore(systemUUID, newWrapper2)`ï¼Œå› ä¸º **G1** è¿˜æ²¡åˆ æ‰é”ï¼Œ**G2** å¾—åˆ°å¹¶è¿”å› `wrapper1.mu` **æ—§çš„æœªåˆ é™¤é”** ï¼Œ`refCount + 1` 
4.  **G1å†ç»§ç»­ forå¾ªç¯ CASæ“ä½œ**

   - æ‰§è¡Œ `s.systemLocks.CompareAndDelete(systemUUID, wrapper1)` ï¼ŒæˆåŠŸåˆ é™¤
- ä½†æ­¤æ—¶ **G2** è¿˜åœ¨ç”¨æ—§é”ï¼Œé”å¯¹è±¡è¢«è¯¯åˆ ã€‚

5. **G2æŒæœ‰æ—§é” wrapper1.mu**ï¼Œä½† `sync.Map` å­˜å‚¨çš„ **key** åˆè¢«è¯¯åˆ  

   - åç»­å¦‚æœæœ‰å…¶ä»– **goroutine** è°ƒç”¨ `GetSystemLock(systemUUID)`ï¼Œä¼šåˆ›å»ºæ–°çš„ **wrapper2**ï¼Œå¯¼è‡´ï¼š

     * ä¸¤ä¸ªä¸åŒçš„ **goroutine** ä½¿ç”¨ä¸åŒçš„é” ***(wrapper1.mu å’Œ wrapper2.muï¼‰***ï¼Œå¤±å»äº’æ–¥ä¿æŠ¤ã€‚

     * ç”±äºå¤±å»ä¿æŠ¤ï¼Œ **countList[num] += 1 ï¼ˆä¸‹æ–‡å•æµ‹ï¼‰ä¹Ÿå¯èƒ½å‘ç”Ÿæ•°æ®ç«äº‰**ï¼Œå¯¼è‡´è®¡æ•°å‡å°‘ï¼ˆéƒ¨åˆ†å†™å…¥ä¸¢å¤±ï¼‰ã€‚

6. åŒæ—¶ **refCount æ³„æ¼** 

   * **wrapper1 çš„ã€‚key** å·²ç»è¢«åˆ é™¤ï¼Œä½† `wrapper1.refCount`  ä»ç„¶è¢« **G2** å¼•ç”¨***ï¼ˆrefCount=1ï¼‰***ã€‚
   * å¦‚æœ **G2** åç»­è°ƒç”¨ `ReleaseLock`ï¼Œå®ƒä¼šå°è¯•å‡å°‘ `wrapper1.refCount`ï¼Œä½† `wrapper1` å·²ç»ä¸åœ¨ `systemLocks` ä¸­ï¼Œå¯èƒ½å¯¼è‡´ï¼š
       * **refCount æ— æ³•å½’é›¶**ï¼Œ`wrapper1` æ°¸è¿œä¸ä¼šè¢« **GC å›æ”¶ï¼ˆå†…å­˜æ³„æ¼ï¼‰** 
       *  `wrapper1.refCount` ä¼šè¢«å‡åˆ°è´Ÿæ•°ï¼Œè‹¥å¼•ç”¨è®¡æ•°å®šä¹‰ä¸º **uint** å¯èƒ½å¯¼è‡´æº¢å‡º

::: caution ä¸ºä½•æœ‰æ—¶æµ‹è¯•æ²¡æœ‰æŠ¥é”™ï¼Ÿ

* **æ—§çš„ sync.Mutex ä»ç„¶æœ‰æ•ˆï¼š** å³ä½¿ **wrapper1** è¢«åˆ é™¤ï¼Œ`wrapper1.mu` ä»ç„¶æ˜¯ä¸€ä¸ª **æœ‰æ•ˆçš„ sync.Mutex** ï¼Œå¯ä»¥æ­£å¸¸åŠ é”è§£é”
* **countList çš„å‡å°‘ä¸æ˜æ˜¾:**  ç”±äºå†²çªæ¦‚ç‡è¾ƒä½ï¼Œéƒ¨åˆ†å†™å…¥ä¸¢å¤±å¯èƒ½è¢«å…¶ä»– **goroutine** çš„å†™å…¥æ©ç›–ï¼Œå¯¼è‡´è®¡æ•°çœ‹èµ·æ¥â€œå·®ä¸å¤šæ­£ç¡®â€
* **æ²¡æœ‰ -race æ£€æµ‹ ï¼š** å¦‚æœæ²¡æœ‰å¯ç”¨ `go test -race` ï¼Œæ•°æ®ç«äº‰å¯èƒ½ä¸ä¼šè¢«å‘ç°ã€‚

:::

### 2.3 å•æµ‹ â€œ-raceâ€ æ£€æµ‹

```go
package main

import (
	"math/rand"
	"strconv"
	"sync"
	"testing"
	"time"
)

func TestSystemLock_ConcurrentAccess(t *testing.T) {
	sl := newGlobalSystemLock()
	var wg sync.WaitGroup
	c := 15
	iterations := c * 1000
	countList := make([]int, c)
	// å¹¶å‘æµ‹è¯•
	wg.Add(iterations)
	for i := 0; i < iterations; i++ {
		newK := i % c
		go func(num int) {
			defer wg.Done()
			mu := sl.GetSystemLock(strconv.Itoa(num))
			mu.Lock()
			//time.Sleep(time.Duration(rand.Intn(2)) * time.Microsecond) // æ¨¡æ‹Ÿå·¥ä½œè´Ÿè½½
			countList[num] += 1
			mu.Unlock()
			sl.ReleaseLock(strconv.Itoa(num))
		}(newK)
	}
	wg.Wait()
	t.Log("countList:", countList, sl.LockCount, sl.UnlockCount)
}
```

æ‰§è¡Œåï¼Œä¼šå¾ˆæ˜æ˜¾çš„çœ‹å‡ºä¸å®¹æ˜“å‘ç°çš„ **æ•°æ®ç«äº‰**

```go
go test -race -v

/* 
=== RUN   TestSystemLock_ConcurrentAccess
==================
WARNING: DATA RACE
Read at 0x00c0001481d0 by goroutine 349:
  test/m.TestSystemLock_ConcurrentAccess.func1()
      /Volumes/develop/zzheng/CODE/zero-one/demo_test.go:26 +0xcc
  test/m.TestSystemLock_ConcurrentAccess.gowrap1()
      /Volumes/develop/zzheng/CODE/zero-one/demo_test.go:29 +0x44
      ...
==================
==================
WARNING: DATA RACE
...
Previous write at 0x00c000296388 by goroutine 376:
  ??()
      -:0 +0x100d56ee8
  sync/atomic.AddInt32()
      <autogenerated>:1 +0x14
  test/m.TestSystemLock_ConcurrentAccess.func1()
      /Volumes/develop/zzheng/CODE/zero-one/demo_test.go:28 +0x11c
  test/m.TestSystemLock_ConcurrentAccess.gowrap1()
      /Volumes/develop/zzheng/CODE/zero-one/demo_test.go:29 +0x44

==================
    demo_test.go:32: countList: [1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000] 15000 14017
    testing.go:1398: race detected during execution of test
--- FAIL: TestSystemLock_ConcurrentAccess (0.07s)
FAIL
exit status 1
FAIL    test/m  0.763s
/*
```

### 2.4 sync.MapåŠ¨æ€é” + å”¯ä¸€IDé˜²ABAï¼ˆæ— æ•ˆï¼‰

```go
//...
type lockWrapper struct {
	mu       *sync.Mutex
	refCount int32 // atomic
	id       int64
}

var idGen int64

func (s *systemLock) GetSystemLock(systemUUID string) *sync.Mutex {
	// ...

	// æ…¢é€Ÿè·¯å¾„åˆ›å»ºæ–°é”
	newID := atomic.AddInt64(&idGen, 1)
	newWrapper := &lockWrapper{
		mu:       &sync.Mutex{},
		refCount: 1,
		id:       newID,
	}
	// ...

	return newWrapper.mu
}

func (s *systemLock) ReleaseLock(systemUUID string) {
	actual, ok := s.systemLocks.Load(systemUUID)
	if !ok {
		return
	}

	wrapper := actual.(*lockWrapper)
	if atomic.AddInt32(&wrapper.refCount, -1) == 0 {
		// ä½¿ç”¨ CompareAndDelete ç¡®ä¿å®‰å…¨åˆ é™¤
		for {
			// å†æ¬¡Loadï¼Œç¡®ä¿æ˜¯åŒä¸€ä¸ªå¯¹è±¡
			current, ok := s.systemLocks.Load(systemUUID)
			if !ok || current.(*lockWrapper).id != wrapper.id {
				return
			}
			if s.systemLocks.CompareAndDelete(systemUUID, wrapper) {
				return
			}
			time.Sleep(time.Duration(rand.Intn(20)) * time.Microsecond)
		}
	}
}
```

**é—®é¢˜æ ¹æºï¼š**

è¯¥å®ç°ä¸­ï¼Œé”å¯¹è±¡æœ¬èº«ï¼ˆlockWrapperï¼‰è¢«å›æ”¶å’Œé‡å»ºï¼Œå³ä½¿æœ‰å”¯ä¸€IDï¼Œä½†é”å¯¹è±¡çš„å†…å­˜åœ°å€å˜äº†ï¼Œå¯¼è‡´ï¼š

1. goroutine A è·å–é”å¯¹è±¡ wrapper1ï¼ˆåœ°å€0x1000ï¼ŒID=1ï¼‰
2. goroutine A åŠ é”ï¼Œä¸šåŠ¡æœªå®Œæˆ
3. goroutine B è·å–é”å¯¹è±¡ wrapper1ï¼ˆåœ°å€0x1000ï¼ŒID=1ï¼‰ï¼ŒrefCount+1
4. goroutine A ä¸šåŠ¡å®Œæˆï¼ŒUnlockï¼ŒReleaseLockï¼ŒrefCount-1=0ï¼Œåˆ é™¤é”å¯¹è±¡
5. goroutine C è·å–é”ï¼Œå‘ç°ä¸å­˜åœ¨ï¼Œæ–°å»ºé”å¯¹è±¡ wrapper2ï¼ˆåœ°å€0x2000ï¼ŒID=2ï¼‰
6. goroutine B ä¸šåŠ¡å®Œæˆï¼ŒUnlockï¼ŒReleaseLockï¼ŒrefCount-1=0ï¼Œå°è¯•åˆ é™¤é”å¯¹è±¡
7. æ­¤æ—¶ wrapper1 å·²ç»è¢«åˆ é™¤äº†ï¼Œwrapper2 æ˜¯æ–°å¯¹è±¡ï¼Œä½† goroutine B è¿˜åœ¨ç”¨ wrapper1

**å…³é”®ç‚¹ï¼ˆä¸ºä»€ä¹ˆç‰ˆæœ¬å·/å”¯ä¸€IDåœ¨è¿™é‡Œä¸å¤Ÿï¼‰ï¼š**

- é”å¯¹è±¡è¢«å›æ”¶åï¼Œgoroutine B è¿˜åœ¨ç”¨æ—§çš„é”å¯¹è±¡ **sync.Map é‡Œå­˜çš„æ˜¯æŒ‡é’ˆï¼Œå°±ç®— goroutineA åˆ é™¤äº† keyï¼Œä¹Ÿä»…æ˜¯æŠŠå…¶æ ‡è®°ï¼Œå¹¶ä¸ä¼šè¢«GCï¼Œåˆ é™¤çš„å®è´¨æ˜¯ï¼š** 
  - å¯¹äº **æŒ‡é’ˆç±»å‹** çš„å€¼ï¼šåªæ˜¯å°† `entry.p` æŒ‡é’ˆä»æŒ‡å‘å®é™…å€¼æ”¹ä¸º `nil` æˆ–æ ‡è®°ä¸º `expunged`ï¼ˆåŸå­æ“ä½œï¼‰
  - å¯¹äº **å€¼ç±»å‹** çš„å€¼ï¼šåŒæ ·æ˜¯é€šè¿‡æ“ä½œæŒ‡é’ˆå®ç°çš„é€»è¾‘åˆ é™¤
  - **ä¸ä¼šä¸»åŠ¨é‡Šæ”¾å†…å­˜**ï¼šåˆ é™¤æ“ä½œä¸ä¼šæ˜¾å¼è°ƒç”¨å†…å­˜é‡Šæ”¾ï¼Œå®é™…å†…å­˜ç”± Go çš„åƒåœ¾å›æ”¶å™¨ç®¡ç†

- å³ä½¿æœ‰ **å”¯ä¸€ID**ï¼Œä½†ä¸»è¦ä¹Ÿæ˜¯ç”¨äº **é˜²æ­¢è¯¯åˆ **ï¼Œç¡®ä¿åˆ é™¤çš„æ˜¯åŒä¸€ä¸ªå¯¹è±¡
- å³ä½¿ç”¨ **CAS** å¯¹æ¯”æŒ‡é’ˆï¼Œåªè¦é”å¯¹è±¡è¢«å›æ”¶åˆæ–°å»ºï¼Œ**ABA** é—®é¢˜ä¾ç„¶å­˜åœ¨ï¼Œå› ä¸ºé”å¯¹è±¡æ˜¯åŠ¨æ€åˆ†é…å’Œå›æ”¶çš„ï¼Œæ²¡æœ‰ **GC** ä¿æŠ¤ï¼Œä¸€æ—¦è¢«å›æ”¶ï¼Œåœ°å€å¯èƒ½è¢«å¤ç”¨
- é™¤éä½ èƒ½ä¿è¯é”å¯¹è±¡è¢«å›æ”¶åï¼Œ**æ‰€æœ‰ goroutine éƒ½ä¸å†è®¿é—®æ—§å¯¹è±¡ï¼Œå¦åˆ™ä¾ç„¶æœ‰ç«æ€**



::: tip **é‚£ä¹ˆæœ‰æ— ç®€å•ä¸”é«˜æ•ˆçš„æ–¹æ³•ï¼Œæ—¢èƒ½å›æ”¶å†…å­˜åˆèƒ½é¿å…ABAï¼Ÿ**

**ç†è®ºä¸Šï¼š**

- æŒ‰å½“å‰çš„æ•°æ®ç»“æ„æ¥å®ç°çš„è¯æ²¡æœ‰ã€‚åªè¦å…è®¸é”å¯¹è±¡è¢«å›æ”¶ï¼Œå°± **å¿…é¡»æœ‰ä¸€ç§æœºåˆ¶ä¿è¯ â€œ åŒä¸€æ—¶åˆ»åªæœ‰ä¸€ä¸ªé”å¯¹è±¡åœ¨ç”¨ â€** ï¼Œè¿™å°±éœ€è¦å…¨å±€é”/åˆ†ç‰‡é”ä¿æŠ¤ç”Ÿå‘½å‘¨æœŸï¼ˆä½†è¿™æ ·å¤æ‚åº¦å’Œæ€§èƒ½éƒ½ä¸å¦‚é™æ€åˆ†æ®µé”ï¼‰

- ä¸šç•Œå¸¸è§çš„åšæ³•æ˜¯ä¸å›æ”¶é”å¯¹è±¡ï¼Œæˆ–è€…å®šæœŸæ‰¹é‡æ¸…ç†é•¿æ—¶é—´ä¸ç”¨çš„é”å¯¹è±¡ï¼ˆä½†è¿™ä¹Ÿä¸èƒ½100%é¿å…æç«¯å¹¶å‘ä¸‹çš„ABAé—®é¢˜ï¼‰ã€‚

- é”å¯¹è±¡å¸¸é©» = æ— é™é•¿åˆ†æ®µé” = æœ€å®‰å…¨æœ€ç®€å•

- åŠ¨æ€å›æ”¶ = å¿…ç„¶æœ‰ABA/ç«æ€é£é™©ï¼Œä¸”å®ç°å¤æ‚

- 99%åœºæ™¯æ¨èé”å¯¹è±¡å¸¸é©»ï¼Œå†…å­˜å ç”¨å¯æ§ï¼Œä»£ç å¥å£®ï¼Œæˆ–è€…ç›´æ¥ä½¿ç”¨é™æ€

å› æ­¤å°† **ReleaseLock** ç›¸å…³çš„åŠ¨æ€å›æ”¶æœºåˆ¶å»é™¤ä¾ç„¶ä¸ä¼šå‡ºç°ç«Ÿæ€é—®é¢˜

:::

### 2.5 ä¸€å¥è¯ç»“è®º

 **åŠ¨æ€é”åªè¦æœ‰ â€œé”å¯¹è±¡å›æ”¶/é‡å»ºâ€ï¼Œå°±æœ‰ABAå’Œæå‰åˆ é™¤é—®é¢˜ï¼Œé”ä¿æŠ¤å°±ä¸å¯é ã€‚é™æ€åˆ†æ®µé”æ°¸ä¸å›æ”¶ï¼Œæœ€å®‰å…¨ã€‚** 

 

#### ä¸šç•Œæ— é”æ•°æ®ç»“æ„çš„ABAè§£å†³æ–¹æ¡ˆ

- æŒ‡é’ˆ+ç‰ˆæœ¬å·ï¼ˆtagged pointerï¼‰ï¼šæ¯æ¬¡ä¿®æ”¹éƒ½å¢åŠ ç‰ˆæœ¬å·ï¼ŒCASæ—¶ä¸€èµ·å¯¹æ¯”

- Hazard Pointerï¼šæ¯ä¸ªçº¿ç¨‹å£°æ˜è‡ªå·±æ­£åœ¨ç”¨å“ªä¸ªæŒ‡é’ˆï¼Œå›æ”¶æ—¶è¦ç­‰æ‰€æœ‰çº¿ç¨‹éƒ½ä¸ç”¨äº†

- Epoch-based GCï¼šåˆ†ä»£å›æ”¶ï¼Œç¡®ä¿æ²¡æœ‰çº¿ç¨‹åœ¨ç”¨æ—¶æ‰å›æ”¶

è¿™äº›æœºåˆ¶éƒ½æ¯”ä½ ç°åœ¨çš„åŠ¨æ€é”å®ç°å¤æ‚å¾ˆå¤šï¼Œä¸”Goæ ‡å‡†åº“æ²¡æœ‰ç›´æ¥æ”¯æŒã€‚

## 3. é™æ€åˆ†æ®µé”

ç»å¤§å¤šæ•°é«˜å¹¶å‘åœºæ™¯ï¼Œé€‚åˆé”å¯¹è±¡æ•°é‡æœ‰é™ï¼ˆå¦‚å‡ åã€å‡ ç™¾ï¼‰ä¸”çƒ­ç‚¹åˆ†å¸ƒå‡åŒ€çš„åœºæ™¯

**âœ… ä¼˜ç‚¹ï¼š** æå…¶ç®€å•ï¼Œæ˜“äºç»´æŠ¤ã€é”å¯¹è±¡å¸¸é©»å†…å­˜ï¼Œæ— GCå‹åŠ›ã€å“ˆå¸Œåˆ†ç‰‡åé”ç«äº‰æå°ï¼Œæ€§èƒ½é«˜

**âŒ ç¼ºç‚¹ï¼š** åˆ†ç‰‡æ•°é‡å›ºå®šï¼ˆæ— æ³•åŠ¨æ€ï¼‰ï¼Œé”å¯¹è±¡æ•°é‡å¤§äºæœ‰å“ˆå¸Œå†²çªã€å°äºæœ‰å†…å­˜æµªè´¹

#### 3.1 é™æ€åˆ†æ®µé”ï¼Œç®€å•å®ç°

```go
var (
    shardCount = 32 // æ ¹æ®å®é™…æƒ…å†µè°ƒæ•´
    shards = make([]sync.Mutex, shardCount)
)

func getShard(systemUUID string) uint32 {
    h := fnv.New32a()
    h.Write([]byte(systemUUID))
    return h.Sum32() % uint32(shardCount)
}

func (s *machine) FirstRegister(machine *common.RegisterMachine, project *model.Project) (string, error) {
    shard := getShard(machine.SystemUUID)
    shards[shard].Lock()
    defer shards[shard].Unlock()
    
    // å®é™…çš„æ³¨å†Œé€»è¾‘
		return s.processRegister(machine, project)
}
```

##### ä¸ºä»€ä¹ˆé™æ€åˆ†æ®µé”ä¸ä¼šæœ‰ABAé—®é¢˜ï¼Ÿ

- é™æ€åˆ†æ®µé”çš„é”å¯¹è±¡å¸¸é©»å†…å­˜ï¼Œæ°¸ä¸åˆ é™¤ï¼ŒåŒä¸€ä¸ªkeyæ°¸è¿œå“ˆå¸Œåˆ°åŒä¸€ä¸ªé”å¯¹è±¡ã€‚

- ä¸ä¼šæœ‰â€œé”å¯¹è±¡è¢«æå‰åˆ é™¤/æ–°å»ºâ€çš„é—®é¢˜ï¼Œé”çš„ç”Ÿå‘½å‘¨æœŸå’Œè¿›ç¨‹ä¸€è‡´ï¼Œæ‰€ä»¥ä¸ä¼šæœ‰ABAé—®é¢˜ã€‚

::: info **shardsæ•°ç»„çš„å¹¶å‘è¯»å†™æ˜¯å¦å­˜åœ¨ç«æ€é—®é¢˜ï¼Ÿ**

**Go** çš„ **slice/array** åªè¦ä¸æ‰©å®¹/ä¸å†™å…¥ï¼Œæ˜¯çº¿ç¨‹å®‰å…¨çš„ã€‚

- åªè¦ä½ å¯¹ **shards** æ•°ç»„çš„æ“ä½œä»…é™äºâ€œè¯»â€ï¼ˆå³è·å–æŸä¸ªåˆ†ç‰‡çš„é”å¯¹è±¡ï¼Œç„¶åå¯¹è¯¥é”åŠ é”/è§£é”ï¼‰

- è¿™é‡Œçš„ **shards** æ˜¯ä¸€ä¸ªé•¿åº¦å›ºå®šçš„ **slice**ï¼Œåˆå§‹åŒ–åä¸å†å˜åŠ¨ï¼Œåªè¯»ä¸å†™ï¼Œæ‰€ä»¥å¹¶å‘è¯» **slice** æœ¬èº«æ˜¯å®‰å…¨çš„
- **è¡¥å……ï¼š** éåŒæ—¶å¹¶å‘å†™åŒä¸€ä¸ª **index** ä¹Ÿä¸ä¼š **DATA RACE** 

##### **å¯èƒ½çš„ç«æ€é£é™©ç‚¹**

- **slice** æœ¬èº«ä¸å˜ï¼Œå…ƒç´ ä¸å˜ï¼Œåªè¯»ï¼Œæ²¡é—®é¢˜
- å”¯ä¸€çš„é£é™©æ˜¯ï¼šå¦‚æœä½ åœ¨ç¨‹åºè¿è¡ŒæœŸé—´æœ‰ä»£ç  **ä¼šé‡æ–°åˆ†é…/æ‰©å®¹/å†™å…¥shardsè¿™ä¸ªslice**ï¼Œé‚£å°±ä¼šæœ‰ç«æ€

##### **å‚è€ƒèµ„æ–™**

- Goå®˜æ–¹FAQï¼š[Are slices thread-safe?](https://golang.org/doc/faq#atomic_maps) 

:::

ä¸‹é¢æ˜¯ä¸€ä¸ªä½¿ç”¨ **é™æ€åˆ†æ®µé”** å’Œ **å…¨å±€äº’æ–¥é”** çš„å•å…ƒæµ‹è¯•å¯¹æ¯”ï¼š

```go
package main

import (
	"strconv"
	"sync"
	"testing"
	"time"
)


func TestShardedLock(t *testing.T) {
	sl := NewShardedLock(100)
	var wg sync.WaitGroup
	iterations := 1000
	countList := make([]int, 10)
	wg.Add(iterations)
	for i := 0; i < iterations; i++ {
		newK := i % 10
		go func(num int) {
			defer wg.Done()
			sl.Lock(strconv.Itoa(num))
			time.Sleep(2 * time.Millisecond) // æ¨¡æ‹Ÿå·¥ä½œè´Ÿè½½
			countList[num] += 1
			sl.Unlock(strconv.Itoa(num))
		}(newK)
	}
	wg.Wait()
	t.Log("countList:", countList)
}

/*
=== RUN   TestShardedLock
    demo_test.go:62: countList: [100 100 100 100 100 100 100 100 100 100]
--- PASS: TestShardedLock (0.23s)
*/

func TestMutex(t *testing.T) {
	var wg sync.WaitGroup
	var mu sync.Mutex
	iterations := 1000
	countList := make([]int, 10)
	wg.Add(iterations)
	for i := 0; i < iterations; i++ {
		newK := i % 10
		go func(num int) {
			defer wg.Done()
			mu.Lock()
			time.Sleep(2 * time.Millisecond) // æ¨¡æ‹Ÿå·¥ä½œè´Ÿè½½
			countList[num] += 1
			mu.Unlock()
		}(newK)
	}
	wg.Wait()
	t.Log("countMap:", countList)

}

/*
=== RUN   TestMutex
    demo_test.go:82: countMap: [100 100 100 100 100 100 100 100 100 100]
--- PASS: TestMutex (2.27s)
*/
```

ä¼˜åŒ–åï¼Œæ€§èƒ½å·®å¼‚æ˜æ˜¾ï¼Œæ•ˆç‡æå‡äº† **10å€** ä¸æ­¢

### 3.2 åˆ†æ®µè¯»å†™é”ï¼ˆè¯»å¤šå†™å°‘ï¼‰

å¦‚éœ€è¯»å†™åˆ†ç¦»ï¼Œæ¨èç”¨åˆ†æ®µè¯»å†™é”ã€‚

```go
type ShardedRWLock struct {
	shards    []sync.RWMutex
	shardMask uint32
}

func NewShardedRWLock(shardCount int) *ShardedRWLock {
	if shardCount <= 0 {
		shardCount = 32
	}
	n := 1
	for n < shardCount {
		n <<= 1
	}
	shardCount = n

	return &ShardedRWLock{
		shards:    make([]sync.RWMutex, shardCount),
		shardMask: uint32(shardCount - 1),
	}
}

func (sl *ShardedRWLock) Lock(key string) {
	idx := sl.getShardIndex(key)
	sl.shards[idx].Lock()
}

func (sl *ShardedRWLock) Unlock(key string) {
	idx := sl.getShardIndex(key)
	sl.shards[idx].Unlock()
}

func (sl *ShardedRWLock) RLock(key string) {
	idx := sl.getShardIndex(key)
	sl.shards[idx].RLock()
}

func (sl *ShardedRWLock) RUnlock(key string) {
	idx := sl.getShardIndex(key)
	sl.shards[idx].RUnlock()
}

func (sl *ShardedRWLock) getShardIndex(key string) uint32 {
	h := fnv.New32a()
	h.Write([]byte(key))
	return h.Sum32() & sl.shardMask
}


var GlobalShardLock = utils.NewShardedLock(32)

func Register(systemUUID string) {
    GlobalShardLock.Lock(systemUUID)
    defer GlobalShardLock.Unlock(systemUUID)
    // ...ä¸šåŠ¡é€»è¾‘...
}
```

### 3.3 å®é™…å»ºè®®

- ç»å¤§å¤šæ•°ä¸šåŠ¡**ç›´æ¥ç”¨ é™æ€åˆ†æ®µé” æˆ– â€œé”å¯¹è±¡å¸¸é©»â€ æ–¹æ¡ˆ**ï¼Œä¸ç”¨æ‹…å¿ƒå†…å­˜é—®é¢˜ï¼ˆæ¯æŠŠé”å‡ åå­—èŠ‚ï¼Œ**ç™¾ä¸‡æŠŠé”ä¹Ÿæ‰å‡ åMB** ï¼‰ã€‚

- åªæœ‰åœ¨é”å¯¹è±¡æ•°é‡ **æå¤§ä¸”ç¨€ç–ã€ä¸”æåº¦å…³æ³¨å†…å­˜** çš„åœºæ™¯ï¼Œæ‰è€ƒè™‘åŠ¨æ€å›æ”¶+å¤æ‚ä¿æŠ¤ï¼Œä¸”éœ€ä¸¥é˜²ABAã€‚

- **æ¨èé™æ€åˆ†æ®µé”ï¼š** é”å¯¹è±¡å¸¸é©»ï¼Œç®€å•é«˜æ•ˆï¼Œé€‚åˆ99%çš„ä¸šåŠ¡ã€‚

- **åŠ¨æ€é”+å®šæœŸæ¸…ç†ï¼š** é€‚åˆæç«¯å¤§è§„æ¨¡ã€é”å¯¹è±¡æ•°é‡æå¤§ä¸”æåº¦ç¨€ç–çš„keyåœºæ™¯ï¼Œä½†å®ç°å¤æ‚ï¼Œä¸”ä»å¯èƒ½å­˜åœ¨çª—å£å¯¼è‡´çš„æå°æ¦‚ç‡ABAé—®é¢˜ã€‚
- å¦‚æœæœ‰æ›´æç«¯çš„éœ€æ±‚ï¼ˆæ¯”å¦‚äº¿çº§keyä¸”å†…å­˜æåº¦æ•æ„Ÿï¼‰ï¼Œå¯ä»¥è€ƒè™‘ **åˆ†å¸ƒå¼é”/å®šæœŸæ¸…ç†+ç‰ˆæœ¬å·ç­‰æ›´å¤æ‚çš„æ–¹æ¡ˆ** ï¼Œä½†ä¸€èˆ¬ä¸šåŠ¡å®Œå…¨æ²¡å¿…è¦ã€‚

- å¦‚æœä½ ç¡®å®è¦ç”¨åŠ¨æ€é”ï¼Œè¯· **ç”¨å¦‚ä¸‹æˆç†Ÿå®ç°ï¼š**
  - [go-zero lockedcalls](https://github.com/zeromicro/go-zero/blob/master/core/syncx/lockedcalls.go) 
  - [go-zero-singleflight](https://github.com/zeromicro/go-zero/blob/master/core/syncx/singleflight.go)  
  - `"golang.org/x/sync/singleflight"`  

### 4. lockedcalls.go 

#### 4.1 åŠ¨æ€åˆ†æ®µé”

éš¾é“å°±æ²¡æœ‰äººå®ç°è¿‡è¿™ç±»åœºæ™¯çš„åŠ¨æ€åˆ†æ®µé”å—ï¼Ÿå…¶å®ä¸ç„¶ï¼Œæ¥çœ‹ä¸€çœ‹ **go-zero** å®˜æ–¹çš„ä¼˜ç§€å®ç°ï¼Œè¯¥å®ç°æ˜¯ä¸ª **é«˜åº¦ä¸“ç”¨çš„åŠ¨æ€åˆ†æ®µé”**ï¼Œå…¶ä»·å€¼åœ¨äºï¼š

1. ç²¾å‡†çš„ **Keyçº§** å¹¶å‘æ§åˆ¶ ğŸ¯
2. ç‹¬ç«‹æ‰§è¡Œä¿è¯ ***ï¼ˆæ— å‰¯ä½œç”¨å…±äº«ï¼‰*** 
3. èµ„æºé«˜æ•ˆç®¡ç† ***ï¼ˆè‡ªåŠ¨æ¸…ç†â™»ï¸ï¼‰*** 

```go
package syncx

import "sync"

type (
	// LockedCalls makes sure the calls with the same key to be called sequentially.
	// For example, A called F, before it's done, B called F, then B's call would not blocked,
	// after A's call finished, B's call got executed.
	// The calls with the same key are independent, not sharing the returned values.
	// A ------->calls F with key and executes<------->returns
	// B ------------------>calls F with key<--------->executes<---->returns
	LockedCalls interface {
		Do(key string, fn func() (any, error)) (any, error)
	}

	lockedGroup struct {
		mu sync.Mutex
		m  map[string]*sync.WaitGroup
	}
)

// NewLockedCalls returns a LockedCalls.
func NewLockedCalls() LockedCalls {
	return &lockedGroup{
		m: make(map[string]*sync.WaitGroup),
	}
}

func (lg *lockedGroup) Do(key string, fn func() (any, error)) (any, error) {
begin:
	lg.mu.Lock()
	if wg, ok := lg.m[key]; ok {
		lg.mu.Unlock()
		wg.Wait()
		goto begin
	}

	return lg.makeCall(key, fn)
}

func (lg *lockedGroup) makeCall(key string, fn func() (any, error)) (any, error) {
	var wg sync.WaitGroup
	wg.Add(1)
	lg.m[key] = &wg
	lg.mu.Unlock()

	defer func() {
		// delete key first, done later. can't reverse the order, because if reverse,
		// another Do call might wg.Wait() without get notified with wg.Done()
		lg.mu.Lock()
		delete(lg.m, key)
		lg.mu.Unlock()
		wg.Done()
	}()

	return fn()
}
```

##### ä¸ºä»€ä¹ˆå…ˆ delete å† wg.Doneï¼Ÿ

å¦‚æœåè¿‡æ¥ï¼š

- åç¨‹Aè°ƒç”¨ wg.Done()
- åç¨‹Bæ”¶åˆ°é€šçŸ¥ä½†å°šæœªè·å–é”
- åç¨‹CæŠ¢åˆ°é”å¹¶é‡æ–°ä½¿ç”¨ç›¸åŒKey
- åç¨‹Bè·å–é”åå‘ç°Keyå·²è¢«å¤ç”¨ â†’ é€»è¾‘é”™è¯¯

å¦‚æœåœºæ™¯éœ€è¦ **ç¡®ä¿ç›¸åŒèµ„æºçš„æ“ä½œä¸²è¡ŒåŒ–ï¼ŒåŒæ—¶å…è®¸ä¸åŒèµ„æºå¹¶è¡Œå¤„ç†**ï¼Œè¯¥å®ç°æ¯” **SingleFlight** æ›´åˆé€‚ï¼Œè€Œå¯¹äºè¯»å¤šå†™å°‘ä¸”ç»“æœå¯å…±äº«çš„åœºæ™¯ï¼Œ**SingleFlight** ä¾ç„¶æ˜¯æ›´å¥½çš„é€‰æ‹©

#### 4.2 ä¸€äº›è¯´æ˜

##### **åŠ¨æ€çš„ä½“ç°ï¼š** 

- é”å¯¹è±¡æ˜¯â€œæŒ‰éœ€åˆ›å»ºã€æŒ‰éœ€é”€æ¯â€çš„ï¼Œåªæœ‰æœ‰è¯·æ±‚çš„keyæ‰ä¼šåˆ†é…é”å¯¹è±¡ï¼Œç”¨å®Œè‡ªåŠ¨å›æ”¶ã€‚

- ä¸éœ€è¦é¢„å…ˆåˆ†é…ä¸€å †é”å¯¹è±¡ï¼Œé”çš„æ•°é‡å’Œå®é™…æ´»è·ƒkeyæ•°é‡ä¸€è‡´ã€‚

##### **é€‚åˆçš„åœºæ™¯** 

- é”å¯¹è±¡æ•°é‡æå¤šæç¨€ç–ï¼šæ¯”å¦‚ä½ æœ‰å‡ ç™¾ä¸‡ã€å‡ åƒä¸‡ä¸ªä¸åŒçš„keyï¼Œä½†æ¯ä¸ªkeyçš„å¹¶å‘å¾ˆä½ï¼Œä¸”å¤§éƒ¨åˆ†keyå¤§éƒ¨åˆ†æ—¶é—´éƒ½æ²¡äººç”¨ã€‚

- å…¸å‹ä¾‹å­ï¼šå¤§è§„æ¨¡åˆ†å¸ƒå¼ç¼“å­˜ã€åˆ†å¸ƒå¼å”¯ä¸€èµ„æºç®¡ç†ã€ç”¨æˆ·çº§åˆ«çš„é™æµ/äº’æ–¥ç­‰ã€‚

##### **å…·ä½“ä¸¾ä¾‹**

- åˆ†å¸ƒå¼ç¼“å­˜çš„æœ¬åœ°äº’æ–¥ï¼šå‡å¦‚ä½ æœ‰1äº¿ä¸ªç¼“å­˜keyï¼Œåªæœ‰æ´»è·ƒkeyæ‰éœ€è¦åŠ é”ï¼Œé™æ€åˆ†æ®µé”ä¼šå¯¼è‡´å¤§é‡keyå“ˆå¸Œåˆ°åŒä¸€åˆ†ç‰‡ï¼Œä¸²è¡Œä¸¥é‡ï¼›åŠ¨æ€é”åˆ™åªä¸ºæ´»è·ƒkeyåˆ†é…é”ï¼Œä¸”äº’ä¸å½±å“ã€‚

- ç”¨æˆ·çº§åˆ«çš„æ“ä½œäº’æ–¥ï¼šæ¯”å¦‚æœ‰1000ä¸‡ç”¨æˆ·ï¼Œåªæœ‰æ´»è·ƒç”¨æˆ·æ‰éœ€è¦åŠ é”ï¼ŒåŠ¨æ€é”å¯ä»¥åšåˆ°â€œç”¨å¤šå°‘åˆ†é…å¤šå°‘â€ã€‚

- å¤§è§„æ¨¡åˆ†å¸ƒå¼ä»»åŠ¡è°ƒåº¦ï¼šæ¯ä¸ªä»»åŠ¡IDéƒ½è¦åŠ é”ï¼Œä½†ä»»åŠ¡IDæ•°é‡æå¤§ä¸”å¤§éƒ¨åˆ†æ—¶é—´ä¸æ´»è·ƒã€‚

| åœºæ™¯/æ–¹æ¡ˆ       | é™æ€åˆ†æ®µé”         | åŠ¨æ€é”                      |
| :-------------- | :----------------- | :-------------------------- |
| é”å¯¹è±¡æ•°é‡æœ‰é™  | æ€§èƒ½æé«˜ï¼Œç®€å•     | æœ‰é¢å¤–å“ˆå¸Œã€GCã€äº’æ–¥CASå¼€é”€ |
| é”å¯¹è±¡æ•°é‡æå¤§  | å“ˆå¸Œå†²çªå¤šï¼Œæ€§èƒ½å·® | æ€§èƒ½å¥½ï¼Œå†…å­˜å ç”¨ä½          |
| çƒ­ç‚¹keyå‡åŒ€     | æ€§èƒ½æé«˜           | æ€§èƒ½é«˜                      |
| çƒ­ç‚¹keyæåº¦ç¨€ç– | å¯èƒ½æœ‰å†²çª         | æ€§èƒ½é«˜                      |
| ä»£ç å¤æ‚åº¦      | ä½                 | é«˜                          |
| ç»´æŠ¤æˆæœ¬        | ä½                 | é«˜                          |

##### ä½ çš„â€œåˆ†å¸ƒå¼æ³¨å†Œâ€åœºæ™¯å±äºå“ªç§ï¼Ÿ

- å¦‚æœä½ çš„ **systemUUID** æ•°é‡æ˜¯æœ‰é™çš„ï¼ˆæ¯”å¦‚å‡ ç™¾ã€å‡ åƒã€å‡ ä¸‡ï¼‰ï¼Œé™æ€åˆ†æ®µé”å®Œå…¨è¶³å¤Ÿï¼Œæ€§èƒ½æœ€å¥½ï¼Œä»£ç æœ€ç®€å•ã€‚

- å¦‚æœä½ çš„ **systemUUID** æ•°é‡æå¤§ï¼ˆæ¯”å¦‚ç™¾ä¸‡çº§ã€åƒä¸‡çº§ï¼‰ï¼Œä¸”å¤§éƒ¨åˆ†æ—¶é—´éƒ½ä¸æ´»è·ƒï¼ŒåŠ¨æ€é”æ‰æœ‰ä¼˜åŠ¿ã€‚

ç»å¤§å¤šæ•°æ³¨å†Œä¸šåŠ¡ï¼Œ**systemUUID** æ•°é‡è¿œå°äºåˆ†ç‰‡æ•°ï¼Œé™æ€åˆ†æ®µé”å°±å¤Ÿå•¦ã€‚

<img src="./img/åŠ¨æ€åˆ†æ®µé”å‹æµ‹.png" /> 



#### é™„ï¼š

è¶…æ—¶è¯»å†™é”

```go
package logic

import (
	"fmt"
	"hash/fnv"
	"sync"
	"sync/atomic"
	"time"
)

// ShardedRWMutex åˆ†æ®µè¯»å†™é”
type ShardedRWMutex struct {
	shards    []*sync.RWMutex
	shardMask uint32
	shardCount int
	stats     *ShardStats
}

// ShardStats åˆ†ç‰‡ç»Ÿè®¡ä¿¡æ¯
type ShardStats struct {
	TotalLocks   int64
	TotalUnlocks int64
	TotalRLocks  int64
	TotalRUnlocks int64
	LastAccess   time.Time
}

// NewShardedRWMutex åˆ›å»ºåˆ†æ®µè¯»å†™é”
func NewShardedRWMutex(shardCount int) *ShardedRWMutex {
	if shardCount <= 0 {
		shardCount = 16 // é»˜è®¤16ä¸ªåˆ†ç‰‡
	}
	
	// ç¡®ä¿åˆ†ç‰‡æ•°é‡æ˜¯2çš„å¹‚æ¬¡ï¼Œä¾¿äºä½è¿ç®—ä¼˜åŒ–
	shardCount = nextPowerOfTwo(shardCount)
	
	shards := make([]*sync.RWMutex, shardCount)
	for i := 0; i < shardCount; i++ {
		shards[i] = &sync.RWMutex{}
	}
	
	return &ShardedRWMutex{
		shards:     shards,
		shardMask:  uint32(shardCount - 1),
		shardCount: shardCount,
		stats:      &ShardStats{},
	}
}

// Lock è·å–å†™é”
func (sl *ShardedRWMutex) Lock(key string) {
	shardIndex := sl.getShardIndex(key)
	sl.shards[shardIndex].Lock()
	atomic.AddInt64(&sl.stats.TotalLocks, 1)
	sl.stats.LastAccess = time.Now()
}

// Unlock é‡Šæ”¾å†™é”
func (sl *ShardedRWMutex) Unlock(key string) {
	shardIndex := sl.getShardIndex(key)
	sl.shards[shardIndex].Unlock()
	atomic.AddInt64(&sl.stats.TotalUnlocks, 1)
}

// RLock è·å–è¯»é”
func (sl *ShardedRWMutex) RLock(key string) {
	shardIndex := sl.getShardIndex(key)
	sl.shards[shardIndex].RLock()
	atomic.AddInt64(&sl.stats.TotalRLocks, 1)
	sl.stats.LastAccess = time.Now()
}

// RUnlock é‡Šæ”¾è¯»é”
func (sl *ShardedRWMutex) RUnlock(key string) {
	shardIndex := sl.getShardIndex(key)
	sl.shards[shardIndex].RUnlock()
	atomic.AddInt64(&sl.stats.TotalRUnlocks, 1)
}

// TryLock å°è¯•è·å–å†™é”ï¼ˆéé˜»å¡ï¼‰
func (sl *ShardedRWMutex) TryLock(key string) bool {
	shardIndex := sl.getShardIndex(key)
	acquired := sl.shards[shardIndex].TryLock()
	if acquired {
		atomic.AddInt64(&sl.stats.TotalLocks, 1)
		sl.stats.LastAccess = time.Now()
	}
	return acquired
}

// TryRLock å°è¯•è·å–è¯»é”ï¼ˆéé˜»å¡ï¼‰
func (sl *ShardedRWMutex) TryRLock(key string) bool {
	shardIndex := sl.getShardIndex(key)
	acquired := sl.shards[shardIndex].TryRLock()
	if acquired {
		atomic.AddInt64(&sl.stats.TotalRLocks, 1)
		sl.stats.LastAccess = time.Now()
	}
	return acquired
}

// getShardIndex æ ¹æ®keyè®¡ç®—åˆ†ç‰‡ç´¢å¼•
func (sl *ShardedRWMutex) getShardIndex(key string) uint32 {
	h := fnv.New32a()
	h.Write([]byte(key))
	return h.Sum32() & sl.shardMask
}

// GetStats è·å–ç»Ÿè®¡ä¿¡æ¯
func (sl *ShardedRWMutex) GetStats() *ShardStats {
	return &ShardStats{
		TotalLocks:    atomic.LoadInt64(&sl.stats.TotalLocks),
		TotalUnlocks:  atomic.LoadInt64(&sl.stats.TotalUnlocks),
		TotalRLocks:   atomic.LoadInt64(&sl.stats.TotalRLocks),
		TotalRUnlocks: atomic.LoadInt64(&sl.stats.TotalRUnlocks),
		LastAccess:    sl.stats.LastAccess,
	}
}

// GetShardInfo è·å–åˆ†ç‰‡ä¿¡æ¯
func (sl *ShardedRWMutex) GetShardInfo() map[string]interface{} {
	return map[string]interface{}{
		"shard_count": sl.shardCount,
		"shard_mask":  sl.shardMask,
		"stats":       sl.GetStats(),
	}
}

// nextPowerOfTwo è®¡ç®—å¤§äºç­‰äºnçš„æœ€å°2çš„å¹‚æ¬¡
func nextPowerOfTwo(n int) int {
	if n <= 1 {
		return 1
	}
	
	power := 1
	for power < n {
		power <<= 1
	}
	return power
}

// ShardedLockWithTimeout å¸¦è¶…æ—¶çš„åˆ†æ®µé”
type ShardedLockWithTimeout struct {
	*ShardedRWMutex
	timeout time.Duration
}

// NewShardedLockWithTimeout åˆ›å»ºå¸¦è¶…æ—¶çš„åˆ†æ®µé”
func NewShardedLockWithTimeout(shardCount int, timeout time.Duration) *ShardedLockWithTimeout {
	return &ShardedLockWithTimeout{
		ShardedRWMutex: NewShardedRWMutex(shardCount),
		timeout:        timeout,
	}
}

// LockWithTimeout å¸¦è¶…æ—¶çš„å†™é”
func (sl *ShardedLockWithTimeout) LockWithTimeout(key string) error {
	shardIndex := sl.getShardIndex(key)
	
	// ä½¿ç”¨channelå®ç°è¶…æ—¶æ§åˆ¶
	done := make(chan bool, 1)
	go func() {
		sl.shards[shardIndex].Lock()
		done <- true
	}()
	
	select {
	case <-done:
		atomic.AddInt64(&sl.stats.TotalLocks, 1)
		sl.stats.LastAccess = time.Now()
		return nil
	case <-time.After(sl.timeout):
		return fmt.Errorf("è·å–é”è¶…æ—¶: %v", sl.timeout)
	}
}

// RLockWithTimeout å¸¦è¶…æ—¶çš„è¯»é”
func (sl *ShardedLockWithTimeout) RLockWithTimeout(key string) error {
	shardIndex := sl.getShardIndex(key)
	
	done := make(chan bool, 1)
	go func() {
		sl.shards[shardIndex].RLock()
		done <- true
	}()
	
	select {
	case <-done:
		atomic.AddInt64(&sl.stats.TotalRLocks, 1)
		sl.stats.LastAccess = time.Now()
		return nil
	case <-time.After(sl.timeout):
		return fmt.Errorf("è·å–è¯»é”è¶…æ—¶: %v", sl.timeout)
	}
}
```



### å•é£

go-zeroçš„

```go
package logic

import (
	"callback-handler/internal/common"
	"callback-handler/internal/domain/entities"
	"callback-handler/internal/domain/dependency"
	"callback-handler/pkg/utils"
	"callback-handler/pkg/crerror"
	"fmt"
	"strings"
	"sync"
	"time"
	
	"github.com/zeromicro/go-zero/core/syncx"
	"github.com/zeromicro/go-zero/core/logx"
	"gopkg.in/yaml.v2"
)

type MachineRegisterLogic struct {
	mu           sync.Mutex
	singleFlight syncx.SingleFlight
	dao          *dependency.DAO
	config       *common.Config
}

func NewMachineRegisterLogic(dao *dependency.DAO, config *common.Config) *MachineRegisterLogic {
	return &MachineRegisterLogic{
		singleFlight: syncx.NewSingleFlight(),
		dao:          dao,
		config:       config,
	}
}

// FirstRegister ä½¿ç”¨SingleFlightæ¨¡å¼å¤„ç†å¹¶å‘æ³¨å†Œ
func (m *MachineRegisterLogic) FirstRegister(machine *common.RegisterMachine, project *entities.Project) (string, error) {
	logx.Info("è®¾å¤‡æ³¨å†Œè¯·æ±‚å¼€å§‹, machine-id(%s), system-uuid(%s)", machine.MachineID, machine.SystemUUID)
	
	// ä½¿ç”¨systemUUIDä½œä¸ºkeyï¼Œç¡®ä¿ç›¸åŒç³»ç»Ÿçš„å¹¶å‘è¯·æ±‚å…±äº«ç»“æœ
	key := fmt.Sprintf("register_system_%s", machine.SystemUUID)
	
	result, err := m.singleFlight.Do(key, func() (interface{}, error) {
		return m.doRegister(machine, project)
	})
	
	if err != nil {
		return "", err
	}
	
	// ç±»å‹æ–­è¨€
	if configStr, ok := result.(string); ok {
		return configStr, nil
	}
	
	return "", fmt.Errorf("æ³¨å†Œç»“æœç±»å‹é”™è¯¯")
}

// doRegister å®é™…çš„æ³¨å†Œé€»è¾‘
func (m *MachineRegisterLogic) doRegister(machine *common.RegisterMachine, project *entities.Project) (string, error) {
	logx.Info("å¼€å§‹å¤„ç†æ³¨å†Œé€»è¾‘, system-uuid(%s)", machine.SystemUUID)
	
	// åˆ›å»ºæœºå™¨ä¿¡æ¯
	ma := &entities.Machine{
		MachineID:     machine.MachineID,
		ProjectID:     machine.ProjectID,
		SystemUUID:    machine.SystemUUID,
		PeerID:        machine.PeerID,
		HostName:      machine.HostName,
		Arch:          machine.Arch,
		Distro:        machine.Distro,
		KernelVersion: machine.KernelVersion,
	}

	// éªŒè¯å¯†ç 
	if machine.Password != project.Password {
		return "", crerror.NewError("æ³¨å†Œçš„å¯†é’¥æœ‰è¯¯ï¼")
	}

	// åˆ†é…IPåœ°å€
	ip, err := m.genNextIP(ma.ProjectID, project.CIDR)
	if err != nil {
		return "", fmt.Errorf("åŠ¨æ€ç”ŸæˆIPå¼‚å¸¸: %v", err)
	}
	logx.Info("ä¸ºæœºå™¨åˆ†é…IP: %s", ip)

	// ç”ŸæˆVPNé…ç½®
	vpnConfig, err := m.generateVPNConfig(ip, project)
	if err != nil {
		return "", fmt.Errorf("ç”ŸæˆVPNé…ç½®å¼‚å¸¸: %v", err)
	}

	// åˆ›å»ºæˆ–è·å–ç³»ç»Ÿä¿¡æ¯ï¼ˆä½¿ç”¨æ•°æ®åº“äº‹åŠ¡ç¡®ä¿åŸå­æ€§ï¼‰
	err = m.createSystemIfNotExists(machine)
	if err != nil {
		return "", fmt.Errorf("å¤„ç†ç³»ç»Ÿä¿¡æ¯å¼‚å¸¸: %v", err)
	}

	// åˆ›å»ºæœºå™¨è®°å½•
	err = m.createMachineRecord(ma, vpnConfig)
	if err != nil {
		return "", fmt.Errorf("åˆ›å»ºæœºå™¨è®°å½•å¼‚å¸¸: %v", err)
	}

	// åŠ å¯†é…ç½®
	encryptedConfig := utils.CBCEncryptConfig(vpnConfig, m.config.AESKey)
	
	logx.Info("æ³¨å†Œå®Œæˆ, machine-id(%s), system-uuid(%s)", machine.MachineID, machine.SystemUUID)
	return encryptedConfig, nil
}

// createSystemIfNotExists åˆ›å»ºç³»ç»Ÿä¿¡æ¯ï¼ˆå¦‚æœä¸å­˜åœ¨ï¼‰
func (m *MachineRegisterLogic) createSystemIfNotExists(machine *common.RegisterMachine) error {
	// ä½¿ç”¨æ•°æ®åº“äº‹åŠ¡ç¡®ä¿åŸå­æ€§
	return m.dao.WithTransaction(func(tx *dependency.DAO) error {
		// æŸ¥è¯¢ç³»ç»Ÿæ˜¯å¦å­˜åœ¨
		_, err := tx.System.GetByID(machine.SystemUUID)
		if err != nil {
			if crerror.IsNotFound(err) {
				logx.Info("ç³»ç»Ÿ(%s)æœªæ³¨å†Œ, å‡†å¤‡åˆ›å»º...", machine.SystemUUID)
				
				// åˆ›å»ºç³»ç»Ÿè®°å½•
				_, err = tx.System.Create(&entities.System{
					ProjectID:  machine.ProjectID,
					SystemUUID: machine.SystemUUID,
					SystemName: machine.SystemName,
				})
				if err != nil {
					return fmt.Errorf("åˆ›å»ºç³»ç»Ÿè®°å½•å¤±è´¥: %v", err)
				}
				logx.Info("ç³»ç»Ÿ(%s)åˆ›å»ºæˆåŠŸ", machine.SystemUUID)
			} else {
				return fmt.Errorf("æŸ¥è¯¢ç³»ç»Ÿä¿¡æ¯å¤±è´¥: %v", err)
			}
		} else {
			logx.Info("ç³»ç»Ÿ(%s)å·²å­˜åœ¨", machine.SystemUUID)
		}
		return nil
	})
}

// createMachineRecord åˆ›å»ºæœºå™¨è®°å½•
func (m *MachineRegisterLogic) createMachineRecord(ma *entities.Machine, configData []byte) error {
	ma.ACL = m.config.VPNConf.DefaultACL
	ma.IPv4 = ma.IPv4
	ma.Status = int8(common.Online)
	ma.VpnStatus = int8(common.Ready)
	ma.Config = string(configData)

	_, err := m.dao.Machine.Create(ma)
	if err != nil {
		return fmt.Errorf("åˆ›å»ºæœºå™¨è®°å½•å¤±è´¥: %v", err)
	}
	
	logx.Info("æœºå™¨è®°å½•åˆ›å»ºæˆåŠŸ, machine-id(%s)", ma.MachineID)
	return nil
}



```





redis

```go
package logic

import (
	"callback-handler/internal/common"
	"callback-handler/internal/domain/entities"
	"callback-handler/internal/domain/dependency"
	"callback-handler/pkg/utils"
	"callback-handler/pkg/crerror"
	"context"
	"fmt"
	"strings"
	"time"
	
	"github.com/zeromicro/go-zero/core/logx"
	"github.com/zeromicro/go-zero/core/stores/redis"
	"gopkg.in/yaml.v2"
)

type MachineRegisterLogicV3 struct {
	dao    *dependency.DAO
	config *common.Config
	redis  *redis.Redis
}

func NewMachineRegisterLogicV3(dao *dependency.DAO, config *common.Config, redis *redis.Redis) *MachineRegisterLogicV3 {
	return &MachineRegisterLogicV3{
		dao:    dao,
		config: config,
		redis:  redis,
	}
}

// FirstRegister ä½¿ç”¨Redisåˆ†å¸ƒå¼é”å¤„ç†å¹¶å‘æ³¨å†Œ
func (m *MachineRegisterLogicV3) FirstRegister(machine *common.RegisterMachine, project *entities.Project) (string, error) {
	logx.Info("è®¾å¤‡æ³¨å†Œè¯·æ±‚å¼€å§‹, machine-id(%s), system-uuid(%s)", machine.MachineID, machine.SystemUUID)
	
	// ä½¿ç”¨systemUUIDä½œä¸ºåˆ†å¸ƒå¼é”çš„key
	lockKey := fmt.Sprintf("register_lock:%s", machine.SystemUUID)
	lockValue := fmt.Sprintf("%s_%d", machine.MachineID, time.Now().UnixNano())
	
	// å°è¯•è·å–åˆ†å¸ƒå¼é”
	ctx := context.Background()
	acquired, err := m.redis.SetnxExCtx(ctx, lockKey, lockValue, 30) // 30ç§’è¶…æ—¶
	if err != nil {
		return "", fmt.Errorf("è·å–åˆ†å¸ƒå¼é”å¤±è´¥: %v", err)
	}
	
	if !acquired {
		logx.Info("è·å–åˆ†å¸ƒå¼é”å¤±è´¥ï¼Œç³»ç»Ÿ(%s)æ­£åœ¨è¢«å…¶ä»–è¯·æ±‚å¤„ç†", machine.SystemUUID)
		return "", crerror.NewError("ç³»ç»Ÿæ­£åœ¨æ³¨å†Œä¸­ï¼Œè¯·ç¨åé‡è¯•")
	}
	
	// ç¡®ä¿é”ä¼šè¢«é‡Šæ”¾
	defer func() {
		// ä½¿ç”¨Luaè„šæœ¬ç¡®ä¿åªæœ‰é”çš„æŒæœ‰è€…æ‰èƒ½é‡Šæ”¾é”
		script := `
			if redis.call("get", KEYS[1]) == ARGV[1] then
				return redis.call("del", KEYS[1])
			else
				return 0
			end
		`
		m.redis.EvalCtx(ctx, script, []string{lockKey}, []string{lockValue})
	}()
	
	// æ‰§è¡Œæ³¨å†Œé€»è¾‘
	return m.doRegister(machine, project)
}

// doRegister å®é™…çš„æ³¨å†Œé€»è¾‘
func (m *MachineRegisterLogicV3) doRegister(machine *common.RegisterMachine, project *entities.Project) (string, error) {
	logx.Info("å¼€å§‹å¤„ç†æ³¨å†Œé€»è¾‘, system-uuid(%s)", machine.SystemUUID)
	
	// åˆ›å»ºæœºå™¨ä¿¡æ¯
	ma := &entities.Machine{
		MachineID:     machine.MachineID,
		ProjectID:     machine.ProjectID,
		SystemUUID:    machine.SystemUUID,
		PeerID:        machine.PeerID,
		HostName:      machine.HostName,
		Arch:          machine.Arch,
		Distro:        machine.Distro,
		KernelVersion: machine.KernelVersion,
	}

	// éªŒè¯å¯†ç 
	if machine.Password != project.Password {
		return "", crerror.NewError("æ³¨å†Œçš„å¯†é’¥æœ‰è¯¯ï¼")
	}

	// ä½¿ç”¨æ•°æ®åº“äº‹åŠ¡ç¡®ä¿åŸå­æ€§
	var result string
	err := m.dao.WithTransaction(func(tx *dependency.DAO) error {
		// 1. æ£€æŸ¥å¹¶åˆ›å»ºç³»ç»Ÿè®°å½•
		err := m.ensureSystemExists(tx, machine)
		if err != nil {
			return err
		}
		
		// 2. åˆ†é…IPåœ°å€
		ip, err := m.genNextIP(tx, ma.ProjectID, project.CIDR)
		if err != nil {
			return fmt.Errorf("åŠ¨æ€ç”ŸæˆIPå¼‚å¸¸: %v", err)
		}
		ma.IPv4 = ip
		logx.Info("ä¸ºæœºå™¨åˆ†é…IP: %s", ip)

		// 3. ç”ŸæˆVPNé…ç½®
		vpnConfig, err := m.generateVPNConfig(ip, project)
		if err != nil {
			return fmt.Errorf("ç”ŸæˆVPNé…ç½®å¼‚å¸¸: %v", err)
		}

		// 4. åˆ›å»ºæœºå™¨è®°å½•
		err = m.createMachineRecord(tx, ma, vpnConfig)
		if err != nil {
			return err
		}

		// 5. åŠ å¯†é…ç½®
		result = utils.CBCEncryptConfig(vpnConfig, m.config.AESKey)
		return nil
	})
	
	if err != nil {
		return "", err
	}
	
	logx.Info("æ³¨å†Œå®Œæˆ, machine-id(%s), system-uuid(%s)", machine.MachineID, machine.SystemUUID)
	return result, nil
}

// ensureSystemExists ç¡®ä¿ç³»ç»Ÿè®°å½•å­˜åœ¨
func (m *MachineRegisterLogicV3) ensureSystemExists(tx *dependency.DAO, machine *common.RegisterMachine) error {
	// å…ˆæŸ¥è¯¢ç³»ç»Ÿæ˜¯å¦å­˜åœ¨
	_, err := tx.System.GetByID(machine.SystemUUID)
	if err != nil {
		if crerror.IsNotFound(err) {
			logx.Info("ç³»ç»Ÿ(%s)æœªæ³¨å†Œ, å‡†å¤‡åˆ›å»º...", machine.SystemUUID)
			
			// åˆ›å»ºç³»ç»Ÿè®°å½•
			_, err = tx.System.Create(&entities.System{
				ProjectID:  machine.ProjectID,
				SystemUUID: machine.SystemUUID,
				SystemName: machine.SystemName,
			})
			if err != nil {
				return fmt.Errorf("åˆ›å»ºç³»ç»Ÿè®°å½•å¤±è´¥: %v", err)
			}
			logx.Info("ç³»ç»Ÿ(%s)åˆ›å»ºæˆåŠŸ", machine.SystemUUID)
		} else {
			return fmt.Errorf("æŸ¥è¯¢ç³»ç»Ÿä¿¡æ¯å¤±è´¥: %v", err)
		}
	} else {
		logx.Info("ç³»ç»Ÿ(%s)å·²å­˜åœ¨", machine.SystemUUID)
	}
	return nil
}

// createMachineRecord åˆ›å»ºæœºå™¨è®°å½•
func (m *MachineRegisterLogicV3) createMachineRecord(tx *dependency.DAO, ma *entities.Machine, configData []byte) error {
	ma.ACL = m.config.VPNConf.DefaultACL
	ma.Status = int8(common.Online)
	ma.VpnStatus = int8(common.Ready)
	ma.Config = string(configData)

	_, err := tx.Machine.Create(ma)
	if err != nil {
		return fmt.Errorf("åˆ›å»ºæœºå™¨è®°å½•å¤±è´¥: %v", err)
	}
	
	logx.Info("æœºå™¨è®°å½•åˆ›å»ºæˆåŠŸ, machine-id(%s)", ma.MachineID)
	return nil
}

// generateVPNConfig ç”ŸæˆVPNé…ç½®
func (m *MachineRegisterLogicV3) generateVPNConfig(ip string, project *entities.Project) ([]byte, error) {
	// è·å–ä¸­ç»§èŠ‚ç‚¹
	relayNodes := m.getRelayNode()
	
	// è·å–CIDRç½‘æ®µ
	cidr, err := m.getCIDRRange()
	if err != nil {
		return nil, fmt.Errorf("è·å–CIDRç½‘æ®µå¤±è´¥: %v", err)
	}
	mask := strings.Split(cidr, "/")[1]

	// è·å–ACLé…ç½®
	acl, err := m.getDefaultACL(m.config.VPNConf.DefaultACL)
	if err != nil {
		return nil, fmt.Errorf("è·å–ACLé…ç½®å¤±è´¥: %v", err)
	}

	// æ„å»ºVPNé…ç½®
	vpnConf := m.config.VPNConf
	config := common.VPNConfig{
		Web:           fmt.Sprintf("0.0.0.0:%d", vpnConf.WebPort),
		MDNS:          vpnConf.MDNS,
		Protocol:      vpnConf.Protocol,
		Listen:        vpnConf.Listen,
		InterfaceAddr: fmt.Sprintf("%s/%s", ip, mask),
		ACL:           acl,
		InterfaceName: vpnConf.InterfaceName,
		LogLevel:      vpnConf.LogLevel,
		Room:          vpnConf.Room,
		RelayNodes:    relayNodes,
	}

	return yaml.Marshal(config)
}

// å…¶ä»–è¾…åŠ©æ–¹æ³•
func (m *MachineRegisterLogicV3) genNextIP(tx *dependency.DAO, projectID string, cidr string) (string, error) {
	// åœ¨äº‹åŠ¡ä¸­å®ç°IPåˆ†é…é€»è¾‘ï¼Œç¡®ä¿åŸå­æ€§
	return "", nil
}

func (m *MachineRegisterLogicV3) getRelayNode() []string {
	return []string{}
}

func (m *MachineRegisterLogicV3) getCIDRRange() (string, error) {
	return "", nil
}

func (m *MachineRegisterLogicV3) getDefaultACL(acl string) (string, error) {
	return acl, nil
}
```





