<template><div><h1 id="分布式监控系统" tabindex="-1"><a class="header-anchor" href="#分布式监控系统" aria-hidden="true">#</a> 分布式监控系统</h1>
<h2 id="监控需求及方式" tabindex="-1"><a class="header-anchor" href="#监控需求及方式" aria-hidden="true">#</a> 监控需求及方式：</h2>
<p>&lt;6&gt;
&lt;7&gt; 数据可视化： 目前有大量 UI 支持
&lt;8&gt; 如何实现单机 5000+： （意味着不能直接存数据库，数据量大会很慢）</p>
<p>&lt;9&gt; 采用何种方式通信：</p>
<ul>
<li>
<p>主动通信：客户端可以主动向服务端要到数据</p>
<ul>
<li>
<p>好处：不用装客户端，使用所有的网络设备，snmp，配置简单</p>
</li>
<li>
<p>坏处：服务器压力大，不适合大型网络环境，不能监控复杂的指标</p>
</li>
</ul>
</li>
<li>
<p>被动通信：服务端被动接受到客户端的汇报数据</p>
<ul>
<li>
<p>好处：大型网络环境、监控复杂的指标、扩展能力强</p>
</li>
<li>
<p>坏处：装客户端、网络设备不适用、维护起来相对复杂一点</p>
</li>
</ul>
</li>
<li>
<p>混合模式：主流，既有主动又有被动</p>
<ul>
<li>
<p>1、客户端知道监控什么指标？ 客户端主动去问服务器我要监控什么</p>
</li>
<li>
<p>2、客户端扫描本地所有服务，全部汇报给服务器 openfalcon 把机器上所有能检测到的都抓上[2014 年自动检测到（支持一千多项)]</p>
</li>
</ul>
</li>
</ul>
<p>&lt;10&gt; 如何实现监控服务器的水平扩展</p>
<h2 id="架构设计" tabindex="-1"><a class="header-anchor" href="#架构设计" aria-hidden="true">#</a> 架构设计：</h2>
<h4 id="存储" tabindex="-1"><a class="header-anchor" href="#存储" aria-hidden="true">#</a> 存储：</h4>
<p>mysql：可以存每个服务器的配置（包括每台服务器要监控的那些资源项等）</p>
<p>redis-server: 并发量大，单机 10w+，存入缓存系统入 redis 中，可以非常的快，可以良好的支持水平扩展</p>
<h4 id="通信模式" tabindex="-1"><a class="header-anchor" href="#通信模式" aria-hidden="true">#</a> 通信模式：</h4>
<p>可采用方式 client -&gt; server 形式</p>
<ul>
<li>
<p>主动通信： Snmp，wget...</p>
</li>
<li>
<p>被动通信： Agent --- （客户端要能和服务端进行通信）</p>
<ul>
<li>•Socket server –&gt; Sockect client 费力不讨好，需要自己处理一切底层机制</li>
</ul>
</li>
<li>
<p>用成熟的 C/S 架构体系：</p>
<ul>
<li>
<p>rbmq：用队列，因为队列也有自己的服务端和客户端，用它自身的 socket</p>
</li>
<li>
<p>rpc：远程调用，如 twisted 自带的 rpc 通信机制的 客户端 Agent 和 服务端 Server 模式，可以支持异步等机制</p>
</li>
<li>
<p>redis：的订阅发布模式</p>
</li>
<li>
<p>http：直接用框架自带的 http，一样有自己的 socket，肯定也支持异步（简化架构、接口设计简单、容易水平扩展做分布式、socket 稳定成熟）</p>
</li>
</ul>
</li>
</ul>
<h4 id="http-特性" tabindex="-1"><a class="header-anchor" href="#http-特性" aria-hidden="true">#</a> Http 特性：</h4>
<p>1.短连接：客户端每次汇报数据后断开，不会给服务器制造压力</p>
<p>2.无状态：服务器端不保存客户端的状态，客户端的每次请求都是独一的，需要带自己的认证信息</p>
<p>3.安全认证：通信不被劫持</p>
<p>4.被动通信：标准的被动通信模式，服务端不会主动连客户端，除非 websocket</p>
<p>[tip]：客户端是不会存储配置信息的，尤其是每一台客户端的监控不一致。因此统一交给服务端来存储配置信息，每次客户端想服务端请求自身的配置
信息。（当前实现是存入 etcd 中，因此避免了服务端挂掉对集群所有客户端的影响）</p>
<p>[注]：若服务端改了一个客户端监控的配置，此时需要主动向客户端推并告知客户端，但是 http 是满足不了需求的，因此可以折中 - watch etcd： 由于本身采用 etcd 来存储各个机器上的告警配置，那么每次变化仅需要去监控 etcd 的告警设置即可，
最好能再弄一个回调机制，监控到有变化才去回调更新给客户端。否则可以开辟 另一个线程 专门负责监控，然后客户端每次轮询监控前，
读一下 线程的共享数据 threading.local() 中的 data_change 标志，若标志由 False 改为 True 则进行重新获取。 - 客户端定期的向服务端去取配置信息，如每 5 分钟向服务端同步配置信息</p>
<h4 id="业务流程-数据通信" tabindex="-1"><a class="header-anchor" href="#业务流程-数据通信" aria-hidden="true">#</a> 业务流程（数据通信）</h4>
<p>汇报数据：客户端向服务端汇报字典结构的数据，其中可以设置 status 字段来标志该监控是否该报警了 0 正常，其他出错了（如执行命令出错了等）</p>
<p>打时间戳：服务器端收到发过来的数据，第一件事就是打时间戳（客户端时间可能是不可信的）</p>
<p>存数据：此时不比对数据，直接存到 redis 里面</p>
<p>比对数据：同一时刻，可能有大量数据送入服务端，此时若去比对阈值，每个客户端的服务都要判断，因此服务端要无时无刻都去判断客户端有没有超
设定的阈值。正常来说应该有个独立的进程或线程或服务来专门干这件事，去不断的比对。</p>
<p>独立进程：Monitor Data Handler 若这个独立进程要比对数据，则还需要不断向 redis 请求数据进行比对（超过阈值的数据写入报警 queue）</p>
<p>需求差异：客户端立刻消费</p>
</div></template>


