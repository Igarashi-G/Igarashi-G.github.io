<template><div><p>一、Python 垃圾回收机制
Python 的垃圾回收机制以引用计数为主，分代收集为辅。若一个对象的引用计数为 0，Python 虚拟机就会回收该对象的内存。
（一）垃圾回收机制：
class ClassA():
def <strong>init</strong>(self):
print 'object born,id:%s'%str(hex(id(self)))
def <strong>del</strong>(self):
print 'object del,id:%s'%str(hex(id(self)))</p>
<pre><code>    def f1():
        while True:
            c1 = ClassA()
            del c1

    当执行 c1 = ClassA()时，就会创建一个对象，放在一块内存中，c1 变量指向这块内存，此时这块内存如 0x237cf58 的引用就是 1。

    del c1后，c1变量不再指向0x237cf58内存，所以这块内存的引用计数减一，等于0，所以就销毁了这个对象，然后释放内存。

    1.导致引用计数+1的情况：
        - 对象被创建，例如 a = 23
        - 对象被引用，例如 b = a
        - 对象被作为参数，传入到一个函数中，例如 func(a)
        - 对象作为一个元素，存储在容器中，例如 list1 = [a, a]

    2.导致引用计数-1的情况：
        - 对象的别名被显式销毁，例如 del a
        - 对象的别名被赋予新的对象，例如 a = 24
        - 一个对象离开它的作用域，例如f函数执行完毕时，func函数中的局部变量（全局变量不会）
        - 对象所在的容器被销毁，或从容器中删除对象

    3.查看一个对象的引用计数：
        sys.getrefcount(a)：参数为对象，这里表示可以查看a对象的引用计数，但是比正常计数大 1，因为调用函数的时候传入a会让a的引用计数 +1

        例：
            a = 1       # sys.getrdfcount(a) - 1 =&gt; 97
            b = 1       # sys.getrdfcount(a) - 1 =&gt; 98  为啥a的引用会+1 是由于a的引用为1，1又被b引用，因此 +1
            b = a       # sys.getrdfcount(a) - 1 =&gt; 98  b引用了a a引用了1 ，因此还是98 ，之前b引用的1不在引用了，因此计数减一

（二）循环引用导致内存泄露
    def f2():
        while True:
            c1=ClassA()
            c2=ClassA()
            c1.t=c2
            c2.t=c1
            del c1
            del c2

    当创建c1，c2后，0x237cf30（c1对应的内存，记为内存1）,0x237cf58（c2对应的内存，记为内存2）这两块内存的引用计数都是1。
    执行c1.t = c2和c2.t = c1后，这两块内存的引用计数变成2。

    在del c1后，内存1的对象的引用计数变为1，由于不是为0，所以内存1的对象不会被销毁，所以内存2的对象的引用数依然是2。
    在del c2后，同理，内存1的对象，内存2的对象的引用数都是1。

    虽然它们两个的对象都是可以被销毁的，但是由于循环引用，导致垃圾回收器都不会回收它们，所以就会导致内存泄露。

（三）垃圾回收
    def f3():
        # print gc.collect()
        c1 = ClassA()
        c2 = ClassA()
        c1.t = c2
        c2.t = c1
        del c1
        del c2
        print(gc.garbage)
        print(gc.collect())  # 显式执行垃圾回收
        print(gc.garbage)
        time.sleep(10)


    if __name__ == '__main__':
        gc.set_debug(gc.DEBUG_LEAK)  # 设置gc模块的日志
        f3()

    garbage：垃圾回收后的对象会放在gc.garbage列表里面
    gc.collect()：会返回不可达的对象数目，4的话就等于两个对象以及它们对应的dict

    有三种情况会触发垃圾回收：
        1.调用gc.collect(),
        2.当gc模块的计数器达到阀值的时候。
        3.程序退出的时候

（四）gc模块常用功能解析(Garbage Collector interface)
    gc模块提供一个接口给开发者设置垃圾回收的选项。
    上面说到，采用引用计数的方法管理内存的一个缺陷是循环引用，而gc模块的一个主要功能就是解决循环引用的问题。

    一、常用API
        1.gc.set_debug(flags)：
            设置gc的debug日志，一般设置为gc.DEBUG_LEAK

        2.gc.collect([generation])：
            显示的进行垃圾回收，输入参数0代表检查第一代对象，1代表检查第一、二代对象...不传参数，执行一个full collection 默认传入2
            返回不可达（即垃圾）对象的数目

        3.gc.set_threshold(threshold0[, threshold1[, threshold2]])：
            设置自动执行垃圾回收的频率。

        4.gc.get_count()：
            获取当前自动执行垃圾回收的计数器，返回一个长度为3的列表

    二、gc模块自动垃圾回收机制：
        必须要import gc模块，并且is_enable()=True才会启动自动垃圾回收。
        这个机制的主要作用就是发现并处理不可达的垃圾对象。垃圾回收=垃圾检查+垃圾回收

        1.在Python中，采用分代收集的方法。把对象分为三代：
            &lt;1&gt;对象在创建的时候，放在一代中
            &lt;2&gt;如果在一次一代的垃圾检查中，改对象存活下来，就会被放到二代中
            &lt;3&gt;在一次二代的垃圾检查中，该对象存活下来，就会被放到三代中。

            因此gc模块里面会有一个长度为3的列表的计数器，可以通过gc.get_count()获取。
            (488,3,0)，其中488是指距离上一次一代垃圾检查，Python分配内存的数目减去释放内存的数目，注意是内存分配，而不是引用计数的增加。

            如：
                print gc.get_count()  # (590, 8, 0)
                a = ClassA()
                print gc.get_count()  # (591, 8, 0) 此时分配内存数目+1

            3是指距离上一次二代垃圾检查，一代垃圾检查的次数，同理，0是指距离上一次三代垃圾检查，二代垃圾检查的次数。

        2.自动垃圾回收的阀值：
            通过gc.get_threshold函数获取到的长度为3的元组，即gc模块获取到自动回收的频率，如(700,10,10) 表示当前阀值
            # 当计数器从(699,3,0)增加到(700,3,0)，gc模块就会执行gc.collect(0),即检查一代对象的垃圾，并重置计数器为(0,4,0)

            # 当计数器从(699,9,0)增加到(700,9,0)，gc模块就会执行gc.collect(1),即检查一、二代对象的垃圾，并重置计数器为(0,0,1)

            # 当计数器从(699,9,9)增加到(700,9,9)，gc模块就会执行gc.collect(2),即检查一、二、三代对象的垃圾，并重置计数器为(0,0,0)

    三、其他：
        如果循环引用中，两个对象都定义了__del__方法，gc模块不会销毁这些不可达对象，因为gc模块不知道应该先调用哪个对象的__del__
        方法，所以为了安全起见，gc模块会把对象放到gc.garbage中，但是不会销毁对象。

（五）应用：
    1.项目中避免循环引用

    2.引入gc模块，启动gc模块的自动清理循环引用的对象机制

    3.由于分代收集，所以把需要长期使用的变量集中管理，并尽快移到二代以后，减少GC检查时的消耗

    4.gc模块唯一处理不了的是循环引用的类都有__del__方法，所以项目中要避免定义__del__方法，如果一定要使用该方法，同时导致了
        循环引用，需要代码显式调用gc.garbage里面的对象的__del__来打破僵局
</code></pre>
</div></template>


