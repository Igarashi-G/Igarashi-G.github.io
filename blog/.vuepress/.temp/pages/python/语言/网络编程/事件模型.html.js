import comp from "/Users/fuuka/Desktop/CODE/Igarashi-G.github.io/blog/.vuepress/.temp/pages/python/语言/网络编程/事件模型.html.vue"
const data = JSON.parse("{\"path\":\"/python/%E8%AF%AD%E8%A8%80/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B.html\",\"title\":\"事件驱动模型\",\"lang\":\"zh-CN\",\"frontmatter\":{\"title\":\"事件驱动模型\",\"order\":2,\"description\":\"事件驱动： 属于一种编程的范式：说白了一种编程的思想，一种编程的风格 传统的编程风格：（是控制流）比如代码块 A 实现了一个功能，代码块 B 实现了一个功能，之后通过一种顺序的执行，跑出一个结果。 线性的：代码块 A-->代码块 B-->代码块 C-->代码块 D-->...-->结束 但是事件驱动是和传统的编程风格完全不同的。而且在以后的公司里大多数...\",\"head\":[[\"script\",{\"type\":\"application/ld+json\"},\"{\\\"@context\\\":\\\"https://schema.org\\\",\\\"@type\\\":\\\"Article\\\",\\\"headline\\\":\\\"事件驱动模型\\\",\\\"image\\\":[\\\"\\\"],\\\"dateModified\\\":null,\\\"author\\\":[{\\\"@type\\\":\\\"Person\\\",\\\"name\\\":\\\"悦·宝宝\\\",\\\"url\\\":\\\"https://github.com/Igarashi-G\\\"}]}\"],[\"meta\",{\"property\":\"og:url\",\"content\":\"https://igarashi-g.github.io/python/%E8%AF%AD%E8%A8%80/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B.html\"}],[\"meta\",{\"property\":\"og:site_name\",\"content\":\"悦 ▪ 宝宝\"}],[\"meta\",{\"property\":\"og:title\",\"content\":\"事件驱动模型\"}],[\"meta\",{\"property\":\"og:description\",\"content\":\"事件驱动： 属于一种编程的范式：说白了一种编程的思想，一种编程的风格 传统的编程风格：（是控制流）比如代码块 A 实现了一个功能，代码块 B 实现了一个功能，之后通过一种顺序的执行，跑出一个结果。 线性的：代码块 A-->代码块 B-->代码块 C-->代码块 D-->...-->结束 但是事件驱动是和传统的编程风格完全不同的。而且在以后的公司里大多数...\"}],[\"meta\",{\"property\":\"og:type\",\"content\":\"article\"}],[\"meta\",{\"property\":\"og:locale\",\"content\":\"zh-CN\"}]]},\"readingTime\":{\"minutes\":31.29,\"words\":9388},\"filePathRelative\":\"python/语言/网络编程/事件模型.md\",\"excerpt\":\"<p>事件驱动：<br>\\n属于一种编程的范式：说白了一种编程的思想，一种编程的风格<br>\\n传统的编程风格：（是控制流）比如代码块 A 实现了一个功能，代码块 B 实现了一个功能，之后通过一种顺序的执行，跑出一个结果。<br>\\n线性的：代码块 A--&gt;代码块 B--&gt;代码块 C--&gt;代码块 D--&gt;...--&gt;结束<br>\\n但是事件驱动是和传统的编程风格完全不同的。而且在以后的公司里大多数情况下都是这种事件驱动的编程方式。</p>\\n<pre><code>什么是事件驱动：\\n    所有的反应都是未知的，都是根据某个事件来触发的。假如网页上的操作，所有的操作对于服务器都是未知的。（类似Android的onclicklistenner，或是\\n    html的表单button之类的，只要点击就会触发某个函数）\\n\\n    对于事件驱动型程序模型，它的流程大致如下：\\n        开始---&gt;初始化---&gt;等待\\n\\n在UI编程中，常常要对鼠标点击进行相应，首先如何获得鼠标点击呢？ 两种方式：\\n\\n    1创建一个线程循环检测是否有鼠标点击：（* 一个线程、死循环）\\n        那么这个方式有以下几个缺点：\\n            1.CPU资源浪费，可能鼠标点击的频率非常小，但是扫描线程还是会一直循环检测，这会造成很多的CPU资源浪费；如果扫描鼠标点击的接口是阻塞的呢？\\n            2.如果是阻塞的，又会出现下面这样的问题，如果我们不但要扫描鼠标点击，还要扫描键盘是否按下，由于扫描鼠标时被阻塞了，那么\\n                可能永远不会去扫描键盘；\\n            3.如果一个循环需要扫描的设备非常多，这又会引来响应时间的问题；\\n            所以，该方式是非常不好的。\\n\\n    2 就是事件驱动模型：\\n        目前大部分的UI编程都是事件驱动模型，如很多UI平台都会提供onClick()事件，这个事件就代表鼠标按下事件。事件驱动模型大体思路如下：\\n            1.有一个事件（消息）队列；\\n            2.鼠标按下时，往这个队列中增加一个点击事件（消息）；\\n            3.有个循环，不断从队列取出事件（处理线程提取任务），根据不同的事件，调用不同的函数，如onClick()、onKeyDown()等；\\n            4.事件（消息）一般都各自保存各自的处理函数指针，这样，每个消息都有独立的处理函数；\\n        （简单来说就是每次点击时，把对应函数添加到队列，等待处理线程来提取调用）\\n\\n事件驱动编程是一种编程范式，这里程序的执行流由外部事件来决定。它的特点是包含一个事件循环，当外部事件发生时使用回调机制来触发相应的处理。\\n另外两种常见的编程范式是（单线程）同步以及多线程编程。\\n</code></pre>\",\"autoDesc\":true}")
export { comp, data }

if (import.meta.webpackHot) {
  import.meta.webpackHot.accept()
  if (__VUE_HMR_RUNTIME__.updatePageData) {
    __VUE_HMR_RUNTIME__.updatePageData(data)
  }
}

if (import.meta.hot) {
  import.meta.hot.accept(({ data }) => {
    __VUE_HMR_RUNTIME__.updatePageData(data)
  })
}
