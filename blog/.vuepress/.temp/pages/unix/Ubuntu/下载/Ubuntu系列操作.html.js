import comp from "D:/Program/Igarashi-G.github.io/blog/.vuepress/.temp/pages/unix/Ubuntu/下载/Ubuntu系列操作.html.vue"
const data = JSON.parse("{\"path\":\"/unix/Ubuntu/%E4%B8%8B%E8%BD%BD/Ubuntu%E7%B3%BB%E5%88%97%E6%93%8D%E4%BD%9C.html\",\"title\":\"认识Ubuntu系统\",\"lang\":\"zh-CN\",\"frontmatter\":{\"title\":\"认识Ubuntu系统\",\"order\":2,\"group\":{\"title\":\"Ubuntu系统\",\"order\":41},\"description\":\"Ubuntu: 注 上篇记录的博客大概是 linux 和旗下 redhat 适用的 有些 ubuntu 稍有区别 更详细的在博客中浏览 这里只为温故有印象（已废弃，改！！）\"},\"readingTime\":{\"minutes\":9.48,\"words\":2843},\"filePathRelative\":\"unix/Ubuntu/下载/Ubuntu系列操作.md\",\"excerpt\":\"<p>Ubuntu: 注 上篇记录的博客大概是 linux 和旗下 redhat 适用的 有些 ubuntu 稍有区别 更详细的在博客中浏览 这里只为温故有印象（已废弃，改！！）</p>\\n<pre><code>用户配置文件 :\\n    已知useradd -m -s /bin/bash user 能系统自动创建好一个用户 那么当自定义时 useradd username 则需要知道\\n    几个用户配置文件.bash_history 存放历史命令 .bash_logout 用户登出 .bashrc .profile\\n    一般在cp /etc/skel/下拷贝\\n    source命令: 加载配置文件 一般上述没有生效(终端还是$符号没有用户名提示时)则用source .bashrc 来再加载一遍\\n\\n    当批量安装时 sudo apt-get install 软件名 -y(批量软件命令) -y表示全部同意 yes 直接赋值安装后自动安装\\n    etc下的配置文件都是个所有用户配置的,其中包括 /bash.bashrc  /profile 等 都是全局性的\\n\\n配置环境变量：·····\\n    一般安装软件都有/software/bin 下面目录有可执行命令\\n    ~/.profile---&gt;PATH=\\\"要添加的路径:$PATH\\\" 这里是修改当前用户的 设置完之后记得source\\n    所有用户则是 /etc/profile ---&gt;同上 但是修改所有人的这种方式不推荐 一般只修改当前用户即可\\n\\n    env:查看当前环境变量 env\\n    export:设置或显示环境变量 export name=\\\"SN\\\"\\n    source:在当前环境下读取并执行FileName中的命令。该filename文件可以无执行权限 source /etc/profile\\n\\necho: erko\\n    默认为空换行 -n不换行 类似print echo $变量名 printf不换行==echo -n 一般不用忽略\\n\\n管道符：|\\n    把前一条命令执行的结果给后一条使用 如 cat -n p.py |sort -rn |wc -l\\n\\n重定向:\\n    &gt;xx.txt 文件空 若文件不存在则创建 存在则清空 类似python的w模式\\n    echo \\\"123\\\"&gt;&gt;xx.txt 追加123到文件\\n\\n查找:\\n    locate 查找所有 包括路径 /etc/sh 只要路径有就能查找出来 不会扫描磁盘,而是从数据库里面拿\\n    locate -i ~/a 搜索用户主目录下所有以a开头的文件并忽略大小写\\n    locate是从数据库查找 每天晚上4点更新 执行sudo updatedb能更新数据库之后即可查找 因此查找当天的文件先更新\\n\\n    find 是把磁盘目录全部遍历一遍\\n    find /home -iname filename 根据文件名查找 i不区分大小写 *通配符\\n    find /home/ -type f根据文件类型查找\\n    反引号`与~在一起 作用是把里面的当做命令来执行 如:ls -a `sudo find / -type f普通文件/l连接/d目录`\\n    sudo find /home/ -maxdepth 2 -type f 指定目录深度来查找 max/min\\n    sudo find /home -size +10M 根据文件大小来查找 b块(512字节)c字节w字(2字节)k千字节 -10k 小于10k\\n    sudo find /home/ -mtime n 其中n为数字 n为5就是 第五天一天的时间段 +5表示五天前的 -5表示后的\\n    对查找结果进行处理 -exec -ok 用的多一点针对删除等敏感操作\\n    很多操作,不详细说明 见博客\\n\\n挂载:挂载后就像系统的某个目录可以复制查看等 就是不能写\\n    df -Th 查看分区如何挂载的 装系统时默认一个分区/dev/sda1\\n    du -sh ./* 查看文件下的目录及大小\\n    du -sh . 查看文件一共有多大 s后面的目录只显示一层 h每一个文件最大的大小\\n\\n    mount:挂载 可以挂载光驱镜像硬盘什么的\\n        sudo mount /dev/cdrom /mnt 此时mnt就是一个挂载点 ls /mnt/挂载了一个光盘\\n    umount:卸载 先挂载新的首先要先卸载再挂载 -l强制卸载\\n        sudo umount /mnt\\n    -o参数 remount 可以不卸载就挂载 还可以指定属性,模式\\n\\n压缩:linux常用\\n    tar:\\n        -c 创建一个压缩文件create\\n        -z 是否同时具有gzip的属性?亦是否需要用gzip压缩\\n        -j 是否同时具有bzip2的属性?亦是否需要用bzip2压缩\\n        -t 查看tarfile里面的文件\\n        -x 解开一个压缩文件的参数指令\\n        -v 压缩文件的过程中显示文件！常用 但不建议用在背景执行过程中\\n        -f 使用档名 请留意在f之后要立即接文件名\\n        -p 使用原来文件的属性(属性不会依据使用者而改变)\\n        -P 可以使用绝对路径来压缩\\n        -N 比后面接的日期还要新才能打包到新建文件中(yyyy/mm/dd)\\n        示例:\\n            tar czvf this.tar.gz ./*txt  将目录下面所有的.txt文件打包压缩归档到this.tar.gz当中\\n            tar xzvf this.tar.gz ./ 将当前目录下的this.tar.gz 中的文件解压到当前文件中\\n        不用zj的就只压缩 不打包\\n            tar -xf this.tar.gz -C /tmp 以指定路径的方式来解压目标到/tmp路径下\\n\\nLinux三剑客之一:\\n    grep:匹配一个给定的模式 其实就是用来做检索的 搜索 过滤\\n        -c --count 计算符合样式的列数\\n        -l --file--with--matches 列出文件名\\n        -i --ignore--case 不区分大小写\\n        -v --revert-match 显示不包含匹配文本的所有行\\n        -E 使用正则表达式RE  指定-E解析为一定使用正则表达式\\n\\n    正则·简 :linux下用的不要太多 几乎没有用不到的地方 后面学python的re模块才真正开始(略有不同)\\n        ^: 匹配开头 这里指的真的只是开头   在[]中^表示取反\\n        $: 匹配结尾\\n        []: 范围匹配\\n        [a-z]:匹配所有小写字母\\n        [A-Z]:大小同上\\n        [0-9]:匹配所有数字 [^0-9] 所有非数字\\n        .: 匹配单个字符  也就是匹配任意字符 当 grep -E \\\".\\\" this.txt 时匹配所有字符\\n        *: 表示*前面的内容出现过0次或多次  如[a-z]*表示 0个或多个小写字母 只和前面的有关 就算[0-9][a-z]*也只和az有关\\n        +: 表示+前面的内容出现过1次或多次  至少出现一次\\n        ?: 表示?前面的内容出现过0次或1次  至多出现一次\\n\\n        因此开头通常为 ^sddsds$来表达\\n        以上必须记下来 必须!!! 应用范围太广\\n\\nLinux三剑客之二:\\n    sed:流编辑器,一次处理一行的数据\\n    sed [-nefr] [动作] [文件]  模式  下面介绍参数\\n        -n: 使用安静模式(slient).在一般的sed用法中,所有来自STDIN的数据一般都会被列出到终端上。但如果加上-n参\\n            数后,则只有经过sed特殊处理的一行才会被列出来\\n        -e: 用的不多 在命令模式上进行sed编辑\\n        -f: 直接将sed的动作写在一个文件内 -f filename 则可以运行filename内的sed动作\\n        -r: sed的动作支持的是延伸型正规表示法语法。(默认是基础正规表示法语法)\\n        -i: 直接修改读取的文件内容,而不是输出到终端\\n\\n    动作说明:[n1[,n2]]动作:\\n        n1,n2 不一定存在,一般代表选择进行动作的行数,比如,如果我的动作是需要在10到20行之间进行的,则10,20动作为1\\n\\n    动作:\\n        #a:新增,a后面可以接字符串,而这些字符串会在新的下一行出现\\n        #c:取代,同a可以接字符串,会取代 n1,n2 之间的行\\n        #d:删除,因为删除 因此不接任何东西\\n            sed \\\"3d\\\" 删除第三行 sed \\\"1,3d\\\"一到三行 sed \\\"/word/,13d\\\"删除目标单词所在的行到第13行\\n            +3则是之后的三行 1~2d 保留偶数行 sed \\\"/56\\\\|76/d\\\"匹配行中有56或是76的则删除 |要转义 不然就当成普通字符\\n\\n        #i:插入,同a,c  i的后面可以接字符串,而这些字符串会出现在新的上一行\\n            sed \\\"3i 2333\\\" 2333则会出现在第三行的上面\\n\\n        #p:列印,亦将某个选择的数据印出。通常p会与参数sed -n 一起运行 用的也不少\\n            sed \\\"3p\\\" 又多打印了第三行一次\\n            sed -n \\\"3p\\\" 只打印了第三行 因为-n只打印了经过处理的行 sed -n \\\"3p;5p\\\" 只打印了三五行\\n            sed -n \\\"3~5p\\\" 从第三行开始隔五行打印\\n            sed -n \\\"$=\\\" 显示文件行数   sed -n \\\"$\\\"p 打印最后一行 p放在里面要转义 \\\"\\\\$p\\\"\\n\\n        #s:替换 可以直接进行取代的工作。通常这个d的动作可以搭配正规表示法,例如1,20s/old/new/g 前面的还好但s用的最多\\n            sed \\\"s///\\\" 标准写法&gt;。&lt;    sed \\\"s/than/2333/\\\" 替换than为2333\\n            sed -r \\\"s/(th)(an)/\\\\2BOOM~\\\\1/\\\" 转义2转义1 -r 双括号进行分组   输出 anBOOM~th\\n\\nLinux三剑客之三: sed&amp;awk 曾被\\\"饭醉团伙\\\"业余爱好者翻译过\\n    awk:一个强大的文本分析工具,相对于grep的查找,sed的编辑,awk在其对数据分析并生成报告时,显得尤为强大.\\n        简单来说awk就是吧文件逐行的读入,以空格为默认分隔符将每行切片,切开的部分再进行各种分析处理\\n\\n    awk [-F field-separator] 'commands' input-file(s) 以上为命令行调用方式\\n    其中 commands是真正awk命令 [-F域分隔符] 是可选的。 input-file(s) 是待处理的文件  在awk中 文件每一行 由\\n    域分隔符分开的每一项称为一个域 通常 在不指定-F域分隔符的情况下 默认的域分隔符是空格\\n        例：tail -10 /etc/passwd | awk -F\\\":\\\" '{print $1}' 取10行passwd下的以\\\":\\\"分割的第一个单词 0就是所有了\\n    awk的工作流程:\\n        读入有'\\\\n'换行符分割的一条记录,然后将记录按指定的 域分隔符划分域,填充域, $0则表示所有域 $n表示第n个域\\n        默认域分隔符是空白键 或 \\\"tab\\\"键 所以$1表示登录用户 $3 表示登录用户ip 以此类推\\n    awk常用内置变量:\\n        ARGC    命令行的参数个数  awk '{print ARGC,ARGV[0],ARGV[1],FILENAME}' a.txt\\n        ARGV    命令行参数排列    其实很少用\\n        ENVIRON    支持队列中系统环境变量的使用\\n        FILENAME    awk浏览文件名\\n        FNR    浏览文件的记录数\\n        FS    设置输入域分隔符 等价于命令 -F选项  awk '{FS=\\\":\\\"}{print NF}' /etc/passwd 这大概就是它的用法吧QAQ\\n        NF    浏览记录的域的个数\\n        NR    已读的记录数\\n        OFS    输出域分隔符 awk 'BEGIN{OFS=\\\"_\\\";}{print $1,$2,$3}'  a.txt  注意别用$0小心被坑\\n        ORS    输出记录分隔符\\n        RS    控制记录分隔符\\n        使用方法 awk '{print ARGC}' a.txt\\n        BEGIN就是在开始之前做一些预定义的动作 END则是结束后去做\\n\\n        awk -F\\\":\\\" '{printf(\\\"filename:%10s,linenumber:%s,columns:%s,linecontent:%s\\\\n\\\",FILENAME,\\n        NR,NF,$0)}' /etc/passwd 这种指令只是更放便阅读\\n\\n\\nvi 和 vim:\\n    vim是vi的升级版 是一款强大的编辑器 有许多命令 小抄请见一章博客\\n    set nu 临时显示行号 若想要每次都显示的话就把 set nu 写到vimrc里\\n    ctrl + r重做 u撤销 ^光标跳到行首 $光标跳到行尾\\n</code></pre>\",\"autoDesc\":true}")
export { comp, data }

if (import.meta.webpackHot) {
  import.meta.webpackHot.accept()
  if (__VUE_HMR_RUNTIME__.updatePageData) {
    __VUE_HMR_RUNTIME__.updatePageData(data)
  }
}

if (import.meta.hot) {
  import.meta.hot.accept(({ data }) => {
    __VUE_HMR_RUNTIME__.updatePageData(data)
  })
}
