import comp from "D:/Program/Igarashi-G.github.io/blog/.vuepress/.temp/pages/database/MySQL/Mysql调优.html.vue"
const data = JSON.parse("{\"path\":\"/database/MySQL/Mysql%E8%B0%83%E4%BC%98.html\",\"title\":\"Mysql调优\",\"lang\":\"zh-CN\",\"frontmatter\":{\"title\":\"Mysql调优\",\"order\":4,\"description\":\"MYSQL 调优 https://www.cnblogs.com/clschao/articles/10463743.html MYSQL 事务：\",\"head\":[[\"script\",{\"type\":\"application/ld+json\"},\"{\\\"@context\\\":\\\"https://schema.org\\\",\\\"@type\\\":\\\"Article\\\",\\\"headline\\\":\\\"Mysql调优\\\",\\\"image\\\":[\\\"\\\"],\\\"dateModified\\\":null,\\\"author\\\":[{\\\"@type\\\":\\\"Person\\\",\\\"name\\\":\\\"悦·宝宝\\\",\\\"url\\\":\\\"https://github.com/Igarashi-G\\\"}]}\"],[\"meta\",{\"property\":\"og:url\",\"content\":\"https://igarashi-g.github.io/database/MySQL/Mysql%E8%B0%83%E4%BC%98.html\"}],[\"meta\",{\"property\":\"og:site_name\",\"content\":\"悦 ▪ 宝宝\"}],[\"meta\",{\"property\":\"og:title\",\"content\":\"Mysql调优\"}],[\"meta\",{\"property\":\"og:description\",\"content\":\"MYSQL 调优 https://www.cnblogs.com/clschao/articles/10463743.html MYSQL 事务：\"}],[\"meta\",{\"property\":\"og:type\",\"content\":\"article\"}],[\"meta\",{\"property\":\"og:locale\",\"content\":\"zh-CN\"}]]},\"readingTime\":{\"minutes\":24.12,\"words\":7236},\"filePathRelative\":\"database/MySQL/Mysql调优.md\",\"excerpt\":\"\\n<p><a href=\\\"https://www.cnblogs.com/clschao/articles/10463743.html\\\" target=\\\"_blank\\\" rel=\\\"noopener noreferrer\\\">https://www.cnblogs.com/clschao/articles/10463743.html</a></p>\\n<pre><code>引擎：\\n    InnoDB：插入时按主键排序插入（最常用） -- 聚集\\n    MYISAM：按照插入时顺序插入 -- 堆表（数据堆在一起）\\n\\n\\n一、页存储：\\n    操作系统中一页的容量为4KB,每一条数据插入时都是插入到页中，\\n    innodb_page_size  = 16384 （16kb）\\n\\n    页结构图：\\n                            File Header\\n                            Page Header\\n                            Infimun + Supremun Records\\n                            - User Records\\n                            - Free Space\\n                            - Page Directory\\n                            File Trailer\\n\\n\\n二、InnoDB行格式：一行记录可以以不同形式记录在InnoDB中，格式分别有\\n    1.Compact：(紧密)\\n        变长字段长度列表 + NULL标志位 + 记录头信息 + 列1~N数据   （格式 外加下文的三个隐藏列）\\n\\n\\n    2.Redundant:\\n\\n    3.Dynamic:(动态)\\n    4.Compressed:(压缩)\\n        这两种行格式类似于COMPACT，只不过在处理行溢出数据时有点分歧，不会在记录的真实数据处 存储一部分数据，\\n        而是把所有的数据都存储到其他页面中去，只在（本该）记录的真实数据处 存储其他页面的地址。\\n        另外Compressed 行格式会采用压缩算法对页面进行压缩。\\n\\n\\n    可以在创建或修改表的语句中指定：\\n        CREATED TABLE 表名 （列的信息） ROW_FORMT=行格式名称\\n        ALTER TABLE 表名 ROW_FORMT=行格式名称\\n\\n\\n    行大小：\\n        定义某一行数据（单个字段）最多有多大，最大长度除开BLOBS这个类型以外的其他字段，最大不能超过65535个字节\\n        a varchar（65535） --会报错  变长字段无NOT NULL则会增加3个字节记录从而占用空间（变长字段列表 + NULL标志位）\\n\\n    行溢出：\\n        因此存在行数据这一页都容不下的可能性，便会将一行的数据 分成几个页去存\\n\\n        方式一： 页存一部分数据 + 下一页的地址\\n\\n        方式二： 页面不存数据， 只存起始页的地址  + 末尾页地址 （和索引有关，将这一页存多条记录，即多个不同页的地址）\\n\\n\\n    记录的真实数据：\\n        除了自定义的列数据以外，还有三个隐藏列:\\n\\n        列名              是否必须        占用空间            描述\\n        row_id              否             6字节         行ID，唯一表示ID\\n        transaction_id      是             7字节           事务ID\\n        roll_pointer        是             7字节           回滚指针\\n\\n        实际上真正名称为：DB_ROW_ID、DB_TRX_ID、DB_ROLL_PTR\\n        若表没有手动定义主键，则会选取一个Unique键作为主键（即唯一索引），若Unique键都没有定义的话，则会默认为表添加一个名为\\n        row_id 的隐藏列作为主键，所以row_id 是在没有自定义主键以及Unique键的情况下才会存在的\\n\\n\\n三、索引：\\n    页目录：\\n        本质是树，即用一个页 利用二分法进行来记录各数据的地址，每一页会有主键，并把主键提出来作为索引部分\\n\\n              页号100                       页号200\\n            1 -&gt;  1111a                   5 -&gt; 5555e\\n                  2222b       -&gt;               6666f\\n            3 -&gt;  3333c...                7 -&gt; 7777g ...\\n\\n    目录页:\\n        额外提出一个页，用来存储页号，但每一页的页号可不是相邻的，反而会再用一个 key-value 去存储页号\\n                    1                          5            --  主键\\n                   100                        200           --  指针\\n                    |                          |\\n                 页号100                    页号200          --  指针指向的行数据\\n\\n        key：每页中最小的值， 利用主键都是递增顺序排列\\n        value：对应的页号\\n\\n    因此就是一个B+树结构(根节点的元素总会留一个在叶子节点上) 一个节点也可以存多个元素\\n                                 0003 0005\\n             |                       |                         |\\n           0002                    0004                       0005\\n        |         |           |            |              |            |\\n    0001   -&gt;    0002   -&gt;   0003    -&gt;   0004   -&gt;    0005    -&gt;    0006 0007\\n\\n    叶子节点：存数据\\n    非叶子节点：存主键 + 指针\\n\\n    所以插入索引的过程中是生成B+树的过程，这就是为什么有序的原因，是存在了B+树的叶子节点里\\n\\n    注：\\n        1.主键ID不适合太长，若过于长的话一页放不下，再会将树的高度拉长，树的高度越高，查找速度就会下降\\n\\n        2.mysql 创建过程略微不同，他是当执行创建表命令时，就会创建一个页，当一个页装不下后，不是在创建第二个页，\\n          而是将第一个页copy一份，创建第二个页，再将之前的第一页改为目录页\\n\\n        3.B+树的优势，相比于AVL树（二叉） B+树的优势在于一个节点可以存多个元素，因此会比AVL树高度要低，因此查找\\n          时的执行效率要低。虽然数据冗余了，查找 = 等于的条件不明显，但查找&gt; &lt; 条件时则不同\\n\\n          例如： 查 &gt; 0002 的数据，可以直接利用索引（0002后的链表指针）提取所有数据，而AVL树要先找出右子树\\n                的节点，之后还要回归父节点，层层遍历  （SQL范围查询）\\n\\n          据说 B+树高度等于2 的时候，大约可存 20000多条数据， B+树高度等于3 的时候， 可以存 2千万多条数据\\n\\n          假设推算：主键用bigint类型 占8字节 指针占6个字节 因此在一页中，可以存多少个非叶子节点\\n                   16kb/(8+6)=1170.28... 可以存1170对 键值对（代表下面有多少个叶子节点）\\n\\n                   此时假设一行数据为1KB，一页存16条数据，那么高度为2的情况下 可存 1170 * 16 = 18724 条数据\\n                   因此用B+树找最多找两次就能在2千多万条数据中找到那个页\\n\\n\\n    辅助索引：\\n        出了主键索引之外，创建的普通索引。好处在于更方便查找，但走辅助索引会走两次，因为建立辅助索引意味着全表\\n        又重新构建了一颗B+树，子节点存的是主键，走辅助索引会先找到主键在去主键表中找数据。\\n        例：\\n            create index idx_t1_bcd on t1(b,c,d);\\n            创建名为idx_t1_bcd的索引，bcd三列必须唯一且会进行排序，并再次生成一个已bcd为 键的B+树\\n\\n        查找方式：\\n        1.辅助索引+ 回表\\n        2.全表扫描\\n\\n        但当一个比较极端的情况，走辅助索引吧全表的主键都找了一遍，此时还不如走全表索引来得快：\\n        create index idx_t1_b on t1(b);   -- 此时只建立一个b的索引（上文索引无）\\n        explain select * from t1 where b &gt; 0; 此时 若走辅助索引还不如走主键全表扫描来的快\\n        因为 b &gt; 0 这个条件吧主键索引都找了出来，又去全表索引再找一遍，这就很慢。\\n\\n        最左前缀原则：\\n            当建立 bcd 三列的索引时，\\n            explain select * from t1 where b = 1 and c = 1 and d = 1; -- 命中索引\\n            explain select * from t1 where c = 1 and d = 1; -- 未命中\\n\\n            若数据从 111 到 644  *11 是没有办法进行比较的，第一个值不知道因此未走索引\\n                                    111     644\\n                                    页号    页号\\n                            |                           |\\n                     111    235                     322     644\\n\\n            explain select * from t1 where b like '%101%';  -- 未命中索引\\n            同上 % 在开头也意味着 第一个值是模糊的,开头可以是多个,而 '101%' 则可以\\n\\n        注：\\n            1.用上文的道理，若要查找已.com 为后缀结尾的 用 %com，则会全表扫描，\\n                可以将 www.baidu.com 、www.google.com 这样的网站逆序存储，然后利用 %moc 进行查找\\n                则可直接命中索引\\n\\n                select * from t1 order by b,c,d;  -- 走全表\\n                select b from t1 order by b,c,d;  -- 命中索引\\n                这是因为 只找一个b字段，b字段本身有索引，因此就无须再走一次全表了\\n\\n\\n            2.NULL 值在MYSQL中小于任何值\\n\\n            3.若其他索引有相同的数据（不是唯一索引），则系统会默认将主键索引也加入B+树的构成中，便于区分\\n</code></pre>\",\"autoDesc\":true}")
export { comp, data }

if (import.meta.webpackHot) {
  import.meta.webpackHot.accept()
  if (__VUE_HMR_RUNTIME__.updatePageData) {
    __VUE_HMR_RUNTIME__.updatePageData(data)
  }
}

if (import.meta.hot) {
  import.meta.hot.accept(({ data }) => {
    __VUE_HMR_RUNTIME__.updatePageData(data)
  })
}
